<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <title>
      Templated Circular Buffer Container
    </title>
    <link rel="stylesheet" href="../../../boost.css" type="text/css">
  </head>
  <body>
    <table id="title" border="0">
      <tr>
        <td>
          <h1>
            Templated Circular Buffer Container
          </h1>
          <h1>
            circular_buffer&lt;T, Alloc&gt;
          </h1>
        </td>
        <td>
          <a href="../../../"><img src="../../../boost.png" width="277" height="86" border="0" alt="Boost"></a>
        </td>
      </tr>
    </table>
    <h2>
      Contents
    </h2>
    <dl>
      <dt>
        <a href="#description">Description</a>
      </dt>
      <dt>
        <a href="#briefexample">Introductory Example</a>
      </dt>
      <dt>
        <a href="#synopsis">Synopsis</a>
      </dt>
      <dt>
        <a href="#rationale">Rationale</a>
      </dt>
      <dd>
        <ul>
          <li>
            <a href="#threadsafety">Thread-Safety</a>
          </li>
          <li>
            <a href="#overwrite">Overwrite Operation</a>
          </li>
          <li>
            <a href="#fullbuffer">Writing to a Full Buffer</a>
          </li>
          <li>
            <a href="#emptybuffer">Reading/Removing from an Empty Buffer</a>
          </li>
          <li>
            <a href="#iteratorinvalidation">Iterator Invalidation</a>
          </li>
        </ul>
      </dd>
      <dt>
        <a href="#caveats">Caveats</a>
      </dt>
      <dt>
        <a href="#debug">Debug Support</a>
      </dt>
      <dt>
        <a href="#interprocess">Compatibility with Interprocess library</a>
      </dt>
      <dt>
        <a href="#examples">More Examples</a>
      </dt>
      <dt>
        <a href="#header">Header Files</a>
      </dt>
      <dt>
        <a href="#model">Modelled Concepts</a>
      </dt>
      <dt>
        <a href="#parameters">Template Parameters</a>
      </dt>
      <dt>
        <a href="#types">Public Types</a>
      </dt>
      <dt>
        <a href="#constructors">Constructors and Destructor</a>
      </dt>
      <dt>
        <a href="#methods">Public Member Functions</a>
      </dt>
      <dt>
        <a href="#functions">Standalone Functions</a>
      </dt>
      <dt>
        <a href="#notes">Notes</a>
      </dt>
      <dt>
        <a href="#see">See also</a>
      </dt>
      <dt>
        <a href="#ack">Acknowledgements</a>
      </dt>
      <dt>
        <a href="#relnotes">Release Notes</a>
      </dt>
    </dl>
    <table id="table_figure" align="right" border="0">
      <tr>
        <td>
          <img src="circular_buffer.png" width="300" height="332" alt="Circular Buffer">
        </td>
      </tr>
      <tr>
        <td width="300">
          <table id="table_figure_desc" cellpadding="5" align="right" border="0">
            <tr>
              <td valign="top">
                <b>Figure:</b>
              </td>
              <td valign="top">
                The circular buffer (for someone known as <i>ring</i> or <i>cyclic buffer</i>).
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <h2>
      <a name="description" id="description">Description</a>
    </h2>
    <p>
      In general the term <i>circular buffer</i> refers to an area in memory which is used to store incoming data. When
      the buffer is filled, new data is written starting at the beginning of the buffer and overwriting the old. (Also
      see the Figure.)
    </p>
    <p>
      The <code>circular_buffer</code> is a STL compliant container. It is a kind of sequence similar to <code><a href=
      "http://www.sgi.com/tech/stl/List.html">std::list</a></code> or <code><a href=
      "http://www.sgi.com/tech/stl/Deque.html">std::deque</a></code>. It supports random access iterators, constant
      time insert and erase operations at the beginning or the end of the buffer and interoperability with
      <code>std</code> algorithms. The <code>circular_buffer</code> is especially designed to provide fixed capacity
      storage. When its capacity is exhausted, newly inserted elements will cause elements either at the beginning or
      end of the buffer (depending on what insert operation is used) to be overwritten.
    </p>
    <p>
      The <code>circular_buffer</code> only allocates memory when created, when the capacity is adjusted explicitly, or
      as necessary to accommodate resizing or assign operations. On the other hand, there is also a <code><a href=
      "space_optimized.html">circular_buffer_space_optimized</a></code> available. It is an adaptor of the
      <code>circular_buffer</code> which does not allocate memory at once when created, rather it allocates memory as
      needed.
    </p>
    <h2>
      <a name="briefexample" id="briefexample">Introductory Example</a>
    </h2>
    <p>
      A brief example using the <code>circular_buffer</code>:
    </p>
    <pre>
   #include &lt;boost/circular_buffer.hpp&gt;

   int main(int /*argc*/, char* /*argv*/[]) {

      // Create a circular buffer with a capacity for 3 integers.
      boost::circular_buffer&lt;int&gt; cb(3);

      // Insert some elements into the buffer.
      cb.push_back(1);
      cb.push_back(2);
      cb.push_back(3);

      int a = cb[0];  // a == 1
      int b = cb[1];  // b == 2
      int c = cb[2];  // c == 3

      // The buffer is full now, pushing subsequent
      // elements will overwrite the front-most elements.

      cb.push_back(4);  // Overwrite 1 with 4.
      cb.push_back(5);  // Overwrite 2 with 5.

      // The buffer now contains 3, 4 and 5.

      a = cb[0];  // a == 3
      b = cb[1];  // b == 4
      c = cb[2];  // c == 5

      // Elements can be popped from either the front or the back.

      cb.pop_back();  // 5 is removed.
      cb.pop_front(); // 3 is removed.

      int d = cb[0];  // d == 4

      return 0;
   }
</pre>
    <h2>
      <a name="synopsis" id="synopsis">Synopsis</a>
    </h2>
    <div id="srcdoc_synopsis">
      <table id="table_synopsis" border="0" cellpadding="10">
        <tr>
          <td>
            <pre>
namespace boost {

template &lt;class <a href="#templateparam_T">T</a>, class <a href="#templateparam_Alloc">Alloc</a>&gt;
class circular_buffer
{
public:
   typedef typename Alloc::value_type <a href=
"#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a>;
   typedef typename Alloc::pointer <a href=
"#classboost_1_1circular__buffer_14ff917f8a6131ec18e91606727592a9c">pointer</a>;
   typedef typename Alloc::const_pointer <a href=
"#classboost_1_1circular__buffer_190f7c6bcb624ad507de546366f49028a">const_pointer</a>;
   typedef typename Alloc::reference <a href=
"#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a>;
   typedef typename Alloc::const_reference <a href=
"#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a>;
   typedef typename Alloc::difference_type <a href=
"#classboost_1_1circular__buffer_15313e723fa85d73db5826f8b722aa2a9">difference_type</a>;
   typedef typename Alloc::size_type <a href=
"#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a>;
   typedef Alloc <a href="#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>;
   typedef <i>implementation-defined</i> <a href=
"#classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9">const_iterator</a>;
   typedef <i>implementation-defined</i> <a href=
"#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a>;
   typedef boost::reverse_iterator&lt;const_iterator&gt; <a href=
"#classboost_1_1circular__buffer_1c7317701b511bc5f7a663b06b53e2b73">const_reverse_iterator</a>;
   typedef boost::reverse_iterator&lt;iterator&gt; <a href=
"#classboost_1_1circular__buffer_1002fb890dded89e75dfeb6f021fb58a5">reverse_iterator</a>;
   typedef std::pair&lt;pointer, size_type&gt; <a href=
"#classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f">array_range</a>;
   typedef std::pair&lt;const_pointer, size_type&gt; <a href=
"#classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025">const_array_range</a>;
   typedef size_type <a href="#classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595">capacity_type</a>;

   explicit <a href=
"#classboost_1_1circular__buffer_1e53e744d2f94a2bcbfcdb219a9d93300">circular_buffer</a>(const allocator_type&amp; alloc = allocator_type());
   explicit <a href=
"#classboost_1_1circular__buffer_18f1606a26fead923c2cbe068a74e28b6">circular_buffer</a>(capacity_type buffer_capacity, const allocator_type&amp; alloc = allocator_type());
   <a href=
"#classboost_1_1circular__buffer_1fdace8f110d5b7a17c02020757f06fe8">circular_buffer</a>(size_type n, const_reference item, const allocator_type&amp; alloc = allocator_type());
   <a href=
"#classboost_1_1circular__buffer_104dc644486d835b56aa479ec48b52230">circular_buffer</a>(capacity_type buffer_capacity, size_type n, const_reference item, const allocator_type&amp; alloc = allocator_type());
   <a href=
"#classboost_1_1circular__buffer_1e515d8a951eeb18b8cc930300e7e13bd">circular_buffer</a>(const circular_buffer&lt;T, Alloc&gt;&amp; cb);
   template &lt;class InputIterator&gt;
      <a href=
"#classboost_1_1circular__buffer_1744ec06b06a5a723386b645a29cb8ed2">circular_buffer</a>(InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());
   template &lt;class InputIterator&gt;
      <a href=
"#classboost_1_1circular__buffer_1a851f75f4a85b1a2b1a241904d21503f">circular_buffer</a>(capacity_type buffer_capacity, InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());
   <a href="#classboost_1_1circular__buffer_164250ffbbbdbc62b99e8301fc195b80c">~circular_buffer</a>();

   allocator_type <a href=
"#classboost_1_1circular__buffer_1a20b7d0e7a4da0af13286df9f53d660c">get_allocator</a>() const;
   allocator_type&amp; <a href="#classboost_1_1circular__buffer_1af7758a36ac2f84a3024b50b4fc7e098">get_allocator</a>();
   iterator <a href="#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin</a>();
   iterator <a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end</a>();
   const_iterator <a href="#classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038">begin</a>() const;
   const_iterator <a href="#classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac">end</a>() const;
   reverse_iterator <a href="#classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa">rbegin</a>();
   reverse_iterator <a href="#classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697">rend</a>();
   const_reverse_iterator <a href=
"#classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026">rbegin</a>() const;
   const_reverse_iterator <a href="#classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3">rend</a>() const;
   reference <a href=
"#classboost_1_1circular__buffer_1d219f0d3203fb43b964a8cf63f1865cd">operator[]</a>(size_type index);
   const_reference <a href=
"#classboost_1_1circular__buffer_1eb0a7fe7f8a56a4dc4c933b93adfcef4">operator[]</a>(size_type index) const;
   reference <a href="#classboost_1_1circular__buffer_1cd84838cb4fffb6c113fd0297e502edc">at</a>(size_type index);
   const_reference <a href=
"#classboost_1_1circular__buffer_1b233a298f5845a0fcf2ecc56f4170810">at</a>(size_type index) const;
   reference <a href="#classboost_1_1circular__buffer_10d5fdeabeb352f47d1f7bb1ea8d9819f">front</a>();
   reference <a href="#classboost_1_1circular__buffer_1d985d974020f88bb4255d8edbae0a30a">back</a>();
   const_reference <a href="#classboost_1_1circular__buffer_10df8595d83bb9d8a7ce50aabc678f90b">front</a>() const;
   const_reference <a href="#classboost_1_1circular__buffer_1027201797868c6274feb6712f670a132">back</a>() const;
   array_range <a href="#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one</a>();
   array_range <a href="#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two</a>();
   const_array_range <a href="#classboost_1_1circular__buffer_10f4b157e27b1170a571417986b239945">array_one</a>() const;
   const_array_range <a href="#classboost_1_1circular__buffer_1bb8eb0f298ad2012c55c5303e1f174d5">array_two</a>() const;
   pointer <a href="#classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e">linearize</a>();
   bool <a href="#classboost_1_1circular__buffer_120f64448dc0723cc68c1096f6b00bc0a">is_linearized</a>() const;
   void <a href=
"#classboost_1_1circular__buffer_1c591bb9e271b10b5240afcff3bd2c619">rotate</a>(const_iterator new_begin);
   size_type <a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size</a>() const;
   size_type <a href="#classboost_1_1circular__buffer_157e2d506bc274b2a63fbe1b8fcafebd7">max_size</a>() const;
   bool <a href="#classboost_1_1circular__buffer_15be1c2a005ec9828549ef6dd7ebed583">empty</a>() const;
   bool <a href="#classboost_1_1circular__buffer_1fd0eef8ba91210d1575404b7e3e8207a">full</a>() const;
   size_type <a href="#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve</a>() const;
   capacity_type <a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity</a>() const;
   void <a href=
"#classboost_1_1circular__buffer_161714204ef5172d156e2c7eccd04998f">set_capacity</a>(capacity_type new_capacity);
   void <a href=
"#classboost_1_1circular__buffer_180c2e2e66a8fa9d0b7adc1b54921a8c3">resize</a>(size_type new_size, const_reference item = value_type());
   void <a href=
"#classboost_1_1circular__buffer_1477715e9d31d2cc5b02ad8ecf3c68c46">rset_capacity</a>(capacity_type new_capacity);
   void <a href=
"#classboost_1_1circular__buffer_144ecd9ec5f54a2d61c7d132e445d3483">rresize</a>(size_type new_size, const_reference item = value_type());
   circular_buffer&lt;T, Alloc&gt;&amp; <a href=
"#classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d">operator=</a>(const circular_buffer&lt;T, Alloc&gt;&amp; cb);
   void <a href=
"#classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada">assign</a>(size_type n, const_reference item);
   void <a href=
"#classboost_1_1circular__buffer_1dbebb80a5f38e52a37ec9f3ed765600a">assign</a>(capacity_type buffer_capacity, size_type n, const_reference item);
   template &lt;class InputIterator&gt;
      void <a href=
"#classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c">assign</a>(InputIterator first, InputIterator last);
   template &lt;class InputIterator&gt;
      void <a href=
"#classboost_1_1circular__buffer_127cab6034beeeb0e11863c8c14d14366">assign</a>(capacity_type buffer_capacity, InputIterator first, InputIterator last);
   void <a href=
"#classboost_1_1circular__buffer_1270ab7074c365663a6f18808024fd88b">swap</a>(circular_buffer&lt;T, Alloc&gt;&amp; cb);
   void <a href=
"#classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e">push_back</a>(const_reference item = value_type());
   void <a href=
"#classboost_1_1circular__buffer_10ef57e73c193682a649d8eb4a1096dce">push_front</a>(const_reference item = value_type());
   void <a href="#classboost_1_1circular__buffer_1df0da00cb501bea75afbbfab9f546a07">pop_back</a>();
   void <a href="#classboost_1_1circular__buffer_18ac972dc24ef7236faa1875de92b9dd8">pop_front</a>();
   iterator <a href=
"#classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95">insert</a>(iterator pos, const_reference item = value_type());
   void <a href=
"#classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140">insert</a>(iterator pos, size_type n, const_reference item);
   template &lt;class InputIterator&gt;
      void <a href=
"#classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6">insert</a>(iterator pos, InputIterator first, InputIterator last);
   iterator <a href=
"#classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c">rinsert</a>(iterator pos, const_reference item = value_type());
   void <a href=
"#classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5">rinsert</a>(iterator pos, size_type n, const_reference item);
   template &lt;class InputIterator&gt;
      void <a href=
"#classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323">rinsert</a>(iterator pos, InputIterator first, InputIterator last);
   iterator <a href="#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase</a>(iterator pos);
   iterator <a href=
"#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase</a>(iterator first, iterator last);
   iterator <a href="#classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f">rerase</a>(iterator pos);
   iterator <a href=
"#classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f">rerase</a>(iterator first, iterator last);
   void <a href="#classboost_1_1circular__buffer_1b25d379cf66ace025036a47ddb344abd">erase_begin</a>(size_type n);
   void <a href="#classboost_1_1circular__buffer_17485ee7f58b01363170114f2123a48d7">erase_end</a>(size_type n);
   void <a href="#classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e">clear</a>();
};

template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_1d35871e838359b5215e1cbb353663207">operator==</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_195b08213f201c2067d8acb024756329d">operator&lt;</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_1f5717e2f6532581a6492ff1839b18f6d">operator!=</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_1f575d7a9741c2044424de50c966c12f3">operator&gt;</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_179abcbacd24b67f08185db54aec8600d">operator&lt;=</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_11c31150380272af67deebef578c80b05">operator&gt;=</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   void <a href=
"#namespaceboost_14aa8f6a2c9640f3f22e266f0fca85777">swap</a>(circular_buffer&lt;T, Alloc&gt;&amp; lhs, circular_buffer&lt;T, Alloc&gt;&amp; rhs);

} // namespace boost
</pre>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="rationale" id="rationale">Rationale</a>
    </h2>
    <p>
      The basic motivation behind the <code>circular_buffer</code> was to create a container which would work
      seamlessly with STL. Additionally, the design of the <code>circular_buffer</code> was guided by the following
      principles:
    </p>
    <ol>
      <li>Maximum <em>efficiency</em> for envisaged applications.
      </li>
      <li>Suitable for <em>general purpose</em> use.
      </li>
      <li>The behaviour of the buffer as <em>intuitive</em> as possible.
      </li>
      <li>Suitable for <em>specialization</em> by means of adaptors. (The <code><a href=
      "space_optimized.html">circular_buffer_space_optimized</a></code> is such an example of the adaptor.)
      </li>
      <li>Easy to <em>debug</em>. (See <a href="#debug">Debug Support</a> for details.)
      </li>
    </ol>
    <p>
      In order to achieve maximum efficiency, the <code>circular_buffer</code> stores its elements in a <em>contiguous
      region of memory</em>, which then enables:
    </p>
    <ol>
      <li>Use of fixed memory and no implicit or unexpected memory allocation.
      </li>
      <li>Fast constant-time insertion and removal of elements from the front and back.
      </li>
      <li>Fast constant-time random access of elements.
      </li>
      <li>Suitability for real-time and performance critical applications.
      </li>
    </ol>
    <p>
      Possible applications of the <code>circular_buffer</code> include:
    </p>
    <ul>
      <li>Storage of the most recently received samples, overwriting the oldest as new samples arrive.
      </li>
      <li>As an underlying container for a <i>bounded buffer</i> (see the <a href="#boundedbuffer">Bounded Buffer
      Example</a>).
      </li>
      <li>A kind of cache storing a specified number of last inserted elements.
      </li>
      <li>Efficient fixed capacity FIFO (First In, First Out) or LIFO (Last In, First Out) queue which removes the
      oldest (inserted as first) elements when full.
      </li>
    </ul>
    <p>
      The following paragraphs describe issues that had to be considered during the implementation of the
      <code>circular_buffer</code>:
    </p>
    <h4>
      <a name="threadsafety" id="threadsafety">Thread-Safety</a>
    </h4>
    <p>
      The thread-safety of the <code>circular_buffer</code> is the same as the thread-safety of containers in most STL
      implementations. This means the <code>circular_buffer</code> is <b>not</b> thread-safe. The thread-safety is
      guarantied only in the sense that simultaneous accesses to <b>distinct</b> instances of the
      <code>circular_buffer</code> are safe, and simultaneous read accesses to a shared <code>circular_buffer</code>
      are safe.
    </p>
    <p>
      If multiple threads access a single <code>circular_buffer</code>, and at least one of the threads may potentially
      write, then the user is responsible for ensuring mutual exclusion between the threads during the container
      accesses. The mutual exclusion between the threads can be achieved by wrapping operations of the underlying
      <code>circular_buffer</code> with a lock acquisition and release. (See the <a href="#boundedbuffer">Bounded
      Buffer Example</a>.)
    </p>
    <h4>
      <a name="overwrite" id="overwrite">Overwrite Operation</a>
    </h4>
    <p>
      Overwrite operation occurs when an element is inserted into a full <code>circular_buffer</code> - the old element
      is being overwritten by the new one. There was a discussion what exactly "overwriting of an element" means during
      the formal review. It may be either a destruction of the original element and a consequent inplace construction
      of a new element or it may be an assignment of a new element into an old one. The <code>circular_buffer</code>
      implements <b>assignment</b> because it is more effective.
    </p>
    <p>
      From the point of business logic of a stored element, the destruction/construction operation and assignment
      usually mean the same. However, in very rare cases (if in any) they may differ. If there is a requirement for
      elements to be destructed/constructed instead of being assigned, consider implementing a wrapper of the element
      which would implement the assign operator, and store the wrappers instead. It is necessary to note that storing
      such wrappers has a drawback. The destruction/construction will be invoked on every assignment of the wrapper -
      not only when a wrapper is being overwritten (when the buffer is full) but also when the stored wrappers are
      being shifted (e.g. as a result of insertion into the middle of container).
    </p>
    <h4>
      <a name="fullbuffer" id="fullbuffer">Writing to a Full Buffer</a>
    </h4>
    <p>
      There are several options how to cope with the case if a data source produces more data than can fit in the
      fixed-sized buffer:
    </p>
    <ol>
      <li>Inform the data source to wait until there is room in the buffer (e.g. by throwing an overflow exception).
      </li>
      <li>If the oldest data is the most important, ignore new data from the source until there is room in the buffer
      again.
      </li>
      <li>If the latest data is the most important, write over the oldest data.
      </li>
      <li>Let the producer to be responsible for checking the size of the buffer prior writing into it.
      </li>
    </ol>
    <p>
      It is apparent that the <code>circular_buffer</code> implements the third option. But it may be less apparent it
      <b>does not</b> implement any other option - especially the first two. One can get an impression that the
      <code>circular_buffer</code> should implement first three options and offer a mechanism of choosing among them.
      This impression is wrong. The <code>circular_buffer</code> was designed and optimized to be circular (which means
      overwriting the oldest data when full). If such a controlling mechanism had been enabled, it would just
      complicate the matters and the usage of the <code>circular_buffer</code> would be probably less straightforward.
    </p>
    <p>
      Moreover, the first two options (and the fourth option as well) do not require the buffer to be circular at all.
      If there is a need for the first or second option, consider implementing an adaptor of e.g.
      <code>std::vector</code>. In this case the <code>circular_buffer</code> is not suitable for adapting, because, in
      contrary to <code>std::vector</code>, it bears an overhead for its circular behaviour.
    </p>
    <h4>
      <a name="emptybuffer" id="emptybuffer">Reading/Removing from an Empty Buffer</a>
    </h4>
    <p>
      When reading or removing an element from an empty buffer, the buffer should be able to notify the data consumer
      (e.g. by throwing underflow exception) that there are no elements stored in it. The <code>circular_buffer</code>
      does not implement such a behaviour for two reasons:
    </p>
    <ol>
      <li>It would introduce performance overhead.
      </li>
      <li>No other <code>std</code> container implements it this way.
      </li>
    </ol>
    <p>
      It is considered to be a bug to read or remove an element (e.g. by calling <code>front()</code> or
      <code>pop_back()</code>) from an empty <code>std</code> container and from an empty <code>circular_buffer</code>
      as well. The data consumer has to test if the container is not empty before reading/removing from it. However,
      when reading from the <code>circular_buffer</code>, there is an option to rely on the <code>at()</code> method
      which throws an exception when the index is out of range.
    </p>
    <h4>
      <a name="iteratorinvalidation" id="iteratorinvalidation">Iterator Invalidation</a>
    </h4>
    <p>
      An iterator is usually considered to be invalidated if an element, the iterator pointed to, had been removed or
      overwritten by an another element. This definition is enforced by the <a href="#debug">Debug Support</a> and is
      documented for every method. However, some applications utilizing <code>circular_buffer</code> may require less
      strict definition: an iterator is invalid only if it points to an uninitialized memory. Consider following
      example:
    </p>
    <pre>
   #define BOOST_CB_DISABLE_DEBUG // The Debug Support has to be disabled, otherwise the code produces a runtime error.

   #include &lt;boost/circular_buffer.hpp&gt;
   #include &lt;assert.h&gt;

   int main(int /*argc*/, char* /*argv*/[]) {

      boost::circular_buffer&lt;int&gt; cb(3);

      cb.push_back(1);
      cb.push_back(2);
      cb.push_back(3);

      boost::circular_buffer&lt;int&gt;::iterator it = cb.begin();

      assert(*it == 1);

      cb.push_back(4);

      assert(*it == 4); // The iterator still points to the initialized memory.

      return 0;
   }
</pre>
    <p>
      The iterator does not point to the original element any more (and is considered to be invalid from the "strict"
      point of view) but it still points to the same <em>valid</em> place in the memory. This "soft" definition of
      iterator invalidation is supported by the <code>circular_buffer</code> but should be considered as an
      implementation detail rather than a full-fledged feature. The rules when the iterator is still valid can be
      inferred from the code in <code><a href=
      "../test/soft_iterator_invalidation.cpp">soft_iterator_invalidation.cpp</a></code>.
    </p>
    <h2>
      <a name="caveats" id="caveats">Caveats</a>
    </h2>
    <p>
      The <code>circular_buffer</code> should not be used for storing pointers to dynamically allocated objects. When a
      <code>circular_buffer</code> becomes full, further insertion will overwrite the stored pointers - resulting in a
      <b>memory leak</b>. One recommend alternative is the use of smart pointers <a href="#note1">[1]</a>. (Any
      container of <code>std::auto_ptr</code> is considered particularly hazardous. <a href="#note2">[2]</a> )
    </p>
    <p>
      While internals of a <code>circular_buffer</code> are circular, iterators are <b>not</b>. Iterators of a
      <code>circular_buffer</code> are only valid for the range <code>[begin(), end()]</code>. E.g. iterators
      <code>(begin() - 1)</code> and <code>(end() + 1)</code> are invalid.
    </p>
    <h2>
      <a name="debug" id="debug">Debug Support</a>
    </h2>
    <p>
      In order to help a programmer to avoid and find common bugs, the <code>circular_buffer</code> contains a kind of
      debug support.
    </p>
    <p>
      The <code>circular_buffer</code> maintains a list of valid iterators. As soon as any element gets destroyed all
      iterators pointing to this element are removed from this list and explicitly invalidated (an invalidation flag is
      set). The debug support also consists of many assertions (<a href=
      "../../utility/assert.html"><code>BOOST_ASSERT</code></a> macros) which ensure the <code>circular_buffer</code>
      and its iterators are used in the correct manner at runtime. In case an invalid iterator is used the assertion
      will report an error. The connection of explicit iterator invalidation and assertions makes a very robust debug
      technique which catches most of the errors.
    </p>
    <p>
      Moreover, the uninitialized memory allocated by <code>circular_buffer</code> is filled with the value
      <code>0xcc</code> in the debug mode. This can help the programmer when debugging the code to recognize the
      initialized memory from the uninitialized. For details refer the source code.
    </p>
    <p>
      The debug support is enabled only in the debug mode (when the <code>NDEBUG</code> is not defined). It can also be
      explicitly disabled (only for <code>circular_buffer</code>) by defining <code>BOOST_CB_DISABLE_DEBUG</code>
      macro.
    </p>
    <h2>
      <a name="intreprocess" id="interprocess">Compatibility with Interprocess library</a>
    </h2>
    <p>
      The <code>circular_buffer</code> is compatible with the <a href="../../../doc/html/interprocess.html">Boost
      Interprocess</a> library used for interprocess communication. Considering that the <code>circular_buffer</code>'s
      debug support relies on 'raw' pointers - which is not permited by the Interprocess library - the code has to
      compiled with <code>-DBOOST_CB_DISABLE_DEBUG</code> or <code>-DNDEBUG</code> (which disables the
      <a href="#debug">Debug Support</a>). Not doing that will cause the compilation to fail.
    </p>
    <h2>
      <a name="examples" id="examples">More Examples</a>
    </h2>
    <p>
      The following example includes various usage of the <code>circular_buffer</code>.
    </p>
    <pre>
   #include &lt;boost/circular_buffer.hpp&gt;
   #include &lt;numeric&gt;
   #include &lt;assert.h&gt;

   int main(int /*argc*/, char* /*argv*/[])
   {
      // create a circular buffer of capacity 3
      boost::circular_buffer&lt;int&gt; cb(3);

      // insert some elements into the circular buffer
      cb.push_back(1);
      cb.push_back(2);

      // assertions
      assert(cb[0] == 1);
      assert(cb[1] == 2);
      assert(!cb.full());
      assert(cb.size() == 2);
      assert(cb.capacity() == 3);

      // insert some other elements
      cb.push_back(3);
      cb.push_back(4);

      // evaluate the sum
      int sum = std::accumulate(cb.begin(), cb.end(), 0);

      // assertions
      assert(cb[0] == 2);
      assert(cb[1] == 3);
      assert(cb[2] == 4);
      assert(*cb.begin() == 2);
      assert(cb.front() == 2);
      assert(cb.back() == 4);
      assert(sum == 9);
      assert(cb.full());
      assert(cb.size() == 3);
      assert(cb.capacity() == 3);

      return 0;
   }
</pre>
    <p>
      The <code>circular_buffer</code> has a capacity of three <code>int</code>. Therefore, the size of the buffer will
      not exceed three. The <code><a href="http://www.sgi.com/tech/stl/accumulate.html">std::accumulate</a></code>
      algorithm evaluates the sum of the stored elements. The semantics of the <code>circular_buffer</code> can be
      inferred from the assertions.
    </p>
    <h4>
      <a name="boundedbuffer" id="boundedbuffer">Bounded Buffer Example</a>
    </h4>
    <p>
      The bounded buffer is normally used in a producer-consumer mode when producer threads produce items and store
      them in the container and consumer threads remove these items and process them. The bounded buffer has to
      guarantee that producers do not insert items into the container when the container is full, that consumers do not
      try to remove items when the container is empty, and that each produced item is consumed by exactly one consumer.
    </p>
    <p>
      The example below shows how the <code>circular_buffer</code> can be utilized as an underlying container of the
      bounded buffer.
    </p>
    <pre>
   #include &lt;boost/circular_buffer.hpp&gt;
   #include &lt;boost/thread/mutex.hpp&gt;
   #include &lt;boost/thread/condition.hpp&gt;
   #include &lt;boost/thread/thread.hpp&gt;
   #include &lt;boost/call_traits.hpp&gt;
   #include &lt;boost/progress.hpp&gt;
   #include &lt;boost/bind.hpp&gt;

   template &lt;class T&gt;
   class bounded_buffer {
   public:

      typedef boost::circular_buffer&lt;T&gt; container_type;
      typedef typename container_type::size_type size_type;
      typedef typename container_type::value_type value_type;
      typedef typename boost::call_traits&lt;value_type&gt;::param_type param_type;

      explicit bounded_buffer(size_type capacity) : m_unread(0), m_container(capacity) {}

      void push_front(boost::call_traits&lt;value_type&gt;::param_type item) {
         // param_type represents the "best" way to pass a parameter of type value_type to a method

         boost::mutex::scoped_lock lock(m_mutex);
         m_not_full.wait(lock, boost::bind(&amp;bounded_buffer&lt;value_type&gt;::is_not_full, this));
         m_container.push_front(item);
         ++m_unread;
         lock.unlock();
         m_not_empty.notify_one();
      }

      void pop_back(value_type* pItem) {
         boost::mutex::scoped_lock lock(m_mutex);
         m_not_empty.wait(lock, boost::bind(&amp;bounded_buffer&lt;value_type&gt;::is_not_empty, this));
         *pItem = m_container[--m_unread];
         lock.unlock();
         m_not_full.notify_one();
      }

   private:
      bounded_buffer(const bounded_buffer&amp;);              // Disabled copy constructor
      bounded_buffer&amp; operator = (const bounded_buffer&amp;); // Disabled assign operator

      bool is_not_empty() const { return m_unread &gt; 0; }
      bool is_not_full() const { return m_unread &lt; m_container.capacity(); }

      size_type m_unread;
      container_type m_container;
      boost::mutex m_mutex;
      boost::condition m_not_empty;
      boost::condition m_not_full;
   };
</pre>
    <p>
      The <code>bounded_buffer</code> relies on <a href="../../thread/doc/">Boost Threads</a> and <a href=
      "../../bind/bind.html">Boost Bind</a> libraries and <a href="../../utility/call_traits.htm">Boost call_traits</a>
      utility.
    </p>
    <p>
      The <code>push_front()</code> method is called by the producer thread in order to insert a new item into the
      buffer. The method locks the mutex and waits until there is a space for the new item. (The mutex is unlocked
      during the waiting stage and has to be regained when the condition is met.) If there is a space in the buffer
      available, the execution continues and the method inserts the item at the end of the
      <code>circular_buffer</code>. Then it increments the number of unread items and unlocks the mutex (in case an
      exception is thrown before the mutex is unlocked, the mutex is unlocked automatically by the destructor of the
      <code>scoped_lock</code>). At last the method notifies one of the consumer threads waiting for a new item to be
      inserted into the buffer.
    </p>
    <p>
      The <code>pop_back()</code> method is called by the consumer thread in order to read the next item from the
      buffer. The method locks the mutex and waits until there is an unread item in the buffer. If there is at least
      one unread item, the method decrements the number of unread items and reads the next item from the
      <code>circular_buffer</code>. Then it unlocks the mutex and notifies one of the producer threads waiting for the
      buffer to free a space for the next item.
    </p>
    <p>
      The <code>pop_back()</code> method does not remove the item but the item is left in the
      <code>circular_buffer</code> which then replaces it with a new one (inserted by a producer) when the
      <code>circular_buffer</code> is full. This technique is more effective than removing the item explicitly by
      calling the <code>pop_back()</code> method of the <code>circular_buffer</code>. This claim is based on the
      assumption that an assignment (replacement) of a new item into an old one is more effective than a destruction
      (removal) of an old item and a consequent inplace construction (insertion) of a new item.
    </p>
    <p>
      For comparison of bounded buffers based on different containers compile and run <a href=
      "../test/bounded_buffer_comparison.cpp">bounded_buffer_comparison.cpp</a>. The test should reveal the bounded
      buffer based on the <code>circular_buffer</code> is most effective closely followed by the
      <code>std::deque</code> based bounded buffer. (In reality the result may differ sometimes because the test is
      always affected by external factors such as immediate CPU load.)
    </p>
    <h2>
      <a name="header" id="header">Header Files</a>
    </h2>
    <p>
      The <code>circular_buffer</code> is defined in the file <code><a href=
      "../../../boost/circular_buffer.hpp">boost/circular_buffer.hpp</a></code>. There is also a forward declaration
      for the <code>circular_buffer</code> in the header file <code><a href=
      "../../../boost/circular_buffer_fwd.hpp">boost/circular_buffer_fwd.hpp</a></code>.
    </p>
    <h2>
      <a name="model" id="model">Modelled Concepts</a>
    </h2>
    <p>
      <a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access Container</a>, <a href=
      "http://www.sgi.com/tech/stl/FrontInsertionSequence.html">Front Insertion Sequence</a> and <a href=
      "http://www.sgi.com/tech/stl/BackInsertionSequence.html">Back Insertion Sequence</a>.
    </p>
    <h2>
      <a name="parameters" id="parameters">Template Parameters</a>
    </h2>
    <div id="srcdoc_params">
      <table id="table_template_params" border="1" cellpadding="3">
        <tr>
          <th>
            Parameter
          </th>
          <th>
            Description
          </th>
          <th>
            Default
          </th>
        </tr>
        <tr>
          <td>
            <a id="templateparam_T" name="templateparam_T"><code>T</code></a>
          </td>
          <td>
            The type of the elements stored in the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Type Requirements:</b>
              </dt>
              <dd>
                The <code>T</code> has to be <a href="http://www.sgi.com/tech/stl/Assignable.html">SGIAssignable</a>
                (SGI STL defined combination of <a href="../../utility/Assignable.html">Assignable</a> and <a href=
                "../../utility/CopyConstructible.html">CopyConstructible</a>). Moreover <code>T</code> has to be
                <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">DefaultConstructible</a> if supplied as
                a default parameter when invoking some of the <code>circular_buffer</code>'s methods e.g.
                <code>insert(iterator pos, const value_type&amp; item = value_type())</code>. And <a href=
                "http://www.sgi.com/tech/stl/EqualityComparable.html">EqualityComparable</a> and/or <a href=
                "../../utility/LessThanComparable.html">LessThanComparable</a> if the <code>circular_buffer</code> will
                be compared with another container.
              </dd>
            </dl>
          </td>
          <td>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="templateparam_Alloc" name="templateparam_Alloc"><code>Alloc</code></a>
          </td>
          <td>
            The allocator type used for all internal memory management.
            <dl>
              <dt>
                <b>Type Requirements:</b>
              </dt>
              <dd>
                The <code>Alloc</code> has to meet the allocator requirements imposed by STL.
              </dd>
            </dl>
          </td>
          <td>
            <code>std::allocator&lt;T&gt;</code>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="types" id="types">Public Types</a>
    </h2>
    <div id="srcdoc_types">
      <table id="table_public_types" border="1" cellpadding="3">
        <tr>
          <th>
            Type
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540" name=
            "classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540"><code>value_type</code></a>
          </td>
          <td>
            The type of elements stored in the <code>circular_buffer</code>.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_14ff917f8a6131ec18e91606727592a9c" name=
            "classboost_1_1circular__buffer_14ff917f8a6131ec18e91606727592a9c"><code>pointer</code></a>
          </td>
          <td>
            A pointer to an element.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_190f7c6bcb624ad507de546366f49028a" name=
            "classboost_1_1circular__buffer_190f7c6bcb624ad507de546366f49028a"><code>const_pointer</code></a>
          </td>
          <td>
            A const pointer to the element.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65" name=
            "classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65"><code>reference</code></a>
          </td>
          <td>
            A reference to an element.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910" name=
            "classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910"><code>const_reference</code></a>
          </td>
          <td>
            A const reference to an element.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15313e723fa85d73db5826f8b722aa2a9" name=
            "classboost_1_1circular__buffer_15313e723fa85d73db5826f8b722aa2a9"><code>difference_type</code></a>
          </td>
          <td>
            The distance type. (A signed integral type used to represent the distance between two iterators.)
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00" name=
            "classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00"><code>size_type</code></a>
          </td>
          <td>
            The size type. (An unsigned integral type that can represent any non-negative value of the container's
            distance type.)
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7" name=
            "classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7"><code>allocator_type</code></a>
          </td>
          <td>
            The type of an allocator used in the <code>circular_buffer</code>.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9" name=
            "classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9"><code>const_iterator</code></a>
          </td>
          <td>
            A const (random access) iterator used to iterate through the <code>circular_buffer</code>.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532" name=
            "classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532"><code>iterator</code></a>
          </td>
          <td>
            A (random access) iterator used to iterate through the <code>circular_buffer</code>.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1c7317701b511bc5f7a663b06b53e2b73" name=
            "classboost_1_1circular__buffer_1c7317701b511bc5f7a663b06b53e2b73"><code>const_reverse_iterator</code></a>
          </td>
          <td>
            A const iterator used to iterate backwards through a <code>circular_buffer</code>.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1002fb890dded89e75dfeb6f021fb58a5" name=
            "classboost_1_1circular__buffer_1002fb890dded89e75dfeb6f021fb58a5"><code>reverse_iterator</code></a>
          </td>
          <td>
            An iterator used to iterate backwards through a <code>circular_buffer</code>.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f" name=
            "classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f"><code>array_range</code></a>
          </td>
          <td>
            An array range. (A typedef for the <a href=
            "http://www.sgi.com/tech/stl/pair.html"><code>std::pair</code></a> where its first element is a pointer to
            a beginning of an array and its second element represents a size of the array.)
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025" name=
            "classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025"><code>const_array_range</code></a>
          </td>
          <td>
            A range of a const array. (A typedef for the <a href=
            "http://www.sgi.com/tech/stl/pair.html"><code>std::pair</code></a> where its first element is a pointer to
            a beginning of a const array and its second element represents a size of the const array.)
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595" name=
            "classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595"><code>capacity_type</code></a>
          </td>
          <td>
            The capacity type. (Same as <code>size_type</code> - defined for consistency with the <a href=
            "space_optimized.html"><code>circular_buffer_space_optimized</code></a>.)
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="constructors" id="constructors">Constructors and Destructor</a>
    </h2>
    <div id="srcdoc_constructors">
      <table id="table_constructors" border="1" cellpadding="3">
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1e53e744d2f94a2bcbfcdb219a9d93300" name=
            "classboost_1_1circular__buffer_1e53e744d2f94a2bcbfcdb219a9d93300"></a><code><b>explicit
            circular_buffer(const <a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            Create an empty <code>circular_buffer</code> with zero capacity.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> == 0
                &amp;&amp; <a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> ==
                0</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>alloc</code>
                  </dt>
                  <dd>
                    The allocator.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Warning:</b>
              </dt>
              <dd>
                Since Boost version 1.36 the behaviour of this constructor has changed. Now the constructor does not
                allocate any memory and both capacity and size are set to zero. Also note when inserting an element
                into a <code>circular_buffer</code> with zero capacity (e.g. by <code><a href=
                "#classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e">push_back(const_reference)</a></code>
                or <code><a href="#classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95">insert(iterator,
                value_type)</a></code>) nothing will be inserted and the size (as well as capacity) remains zero.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                You can explicitly set the capacity by calling the <code><a href=
                "#classboost_1_1circular__buffer_161714204ef5172d156e2c7eccd04998f">set_capacity(capacity_type)</a></code>
                method or you can use the other constructor with the capacity specified.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_18f1606a26fead923c2cbe068a74e28b6">circular_buffer(capacity_type,
                const allocator_type&amp; alloc)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_161714204ef5172d156e2c7eccd04998f">set_capacity(capacity_type)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_18f1606a26fead923c2cbe068a74e28b6" name=
            "classboost_1_1circular__buffer_18f1606a26fead923c2cbe068a74e28b6"></a><code><b>explicit
            circular_buffer(<a href=
            "#classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595">capacity_type</a> buffer_capacity,
            const <a href="#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp;
            alloc = allocator_type());</b></code><br>
            <br>
            Create an empty <code>circular_buffer</code> with the specified capacity.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> ==
                buffer_capacity &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> == 0</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>buffer_capacity</code>
                  </dt>
                  <dd>
                    The maximum number of elements which can be stored in the <code>circular_buffer</code>.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>alloc</code>
                  </dt>
                  <dd>
                    The allocator.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1fdace8f110d5b7a17c02020757f06fe8" name=
            "classboost_1_1circular__buffer_1fdace8f110d5b7a17c02020757f06fe8"></a><code><b>circular_buffer(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> item, const
            <a href="#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            Create a full <code>circular_buffer</code> with the specified capacity and filled with <code>n</code>
            copies of <code>item</code>.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> == n
                &amp;&amp; <a href="#classboost_1_1circular__buffer_1fd0eef8ba91210d1575404b7e3e8207a">full()</a>
                &amp;&amp; (*this)[0] == item &amp;&amp; (*this)[1] == item &amp;&amp; ... &amp;&amp; (*this)[n - 1] ==
                item</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>n</code>
                  </dt>
                  <dd>
                    The number of elements the created <code>circular_buffer</code> will be filled with.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element the created <code>circular_buffer</code> will be filled with.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>alloc</code>
                  </dt>
                  <dd>
                    The allocator.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the <code>n</code>).
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_104dc644486d835b56aa479ec48b52230" name=
            "classboost_1_1circular__buffer_104dc644486d835b56aa479ec48b52230"></a><code><b>circular_buffer(<a href=
            "#classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595">capacity_type</a> buffer_capacity,
            <a href="#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> item, const
            <a href="#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            Create a <code>circular_buffer</code> with the specified capacity and filled with <code>n</code> copies of
            <code>item</code>.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>buffer_capacity &gt;= n</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> ==
                buffer_capacity &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> == n &amp;&amp;
                (*this)[0] == item &amp;&amp; (*this)[1] == item &amp;&amp; ... &amp;&amp; (*this)[n - 1] ==
                item</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>buffer_capacity</code>
                  </dt>
                  <dd>
                    The capacity of the created <code>circular_buffer</code>.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>n</code>
                  </dt>
                  <dd>
                    The number of elements the created <code>circular_buffer</code> will be filled with.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element the created <code>circular_buffer</code> will be filled with.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>alloc</code>
                  </dt>
                  <dd>
                    The allocator.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the <code>n</code>).
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1e515d8a951eeb18b8cc930300e7e13bd" name=
            "classboost_1_1circular__buffer_1e515d8a951eeb18b8cc930300e7e13bd"></a><code><b>circular_buffer(const
            circular_buffer&lt;T,Alloc&gt;&amp; cb);</b></code><br>
            <br>
            The copy constructor.
            <p>
              Creates a copy of the specified <code>circular_buffer</code>.
            </p>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code>*this == cb</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>cb</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to be copied.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the size of <code>cb</code>).
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1744ec06b06a5a723386b645a29cb8ed2" name=
            "classboost_1_1circular__buffer_1744ec06b06a5a723386b645a29cb8ed2"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                circular_buffer(InputIterator first, InputIterator last, const <a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            Create a full <code>circular_buffer</code> filled with a copy of the range.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>.<br>
                <code>first</code> and <code>last</code> have to meet the requirements of <a href=
                "http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> ==
                std::distance(first, last) &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_1fd0eef8ba91210d1575404b7e3e8207a">full()</a> &amp;&amp; (*this)[0]==
                *first &amp;&amp; (*this)[1] == *(first + 1) &amp;&amp; ... &amp;&amp; (*this)[std::distance(first,
                last) - 1] == *(last - 1)</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>first</code>
                  </dt>
                  <dd>
                    The beginning of the range to be copied.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>last</code>
                  </dt>
                  <dd>
                    The end of the range to be copied.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>alloc</code>
                  </dt>
                  <dd>
                    The allocator.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the <code>std::distance(first, last)</code>).
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1a851f75f4a85b1a2b1a241904d21503f" name=
            "classboost_1_1circular__buffer_1a851f75f4a85b1a2b1a241904d21503f"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                circular_buffer(<a href=
            "#classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595">capacity_type</a> buffer_capacity,
            InputIterator first, InputIterator last, const <a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            Create a <code>circular_buffer</code> with the specified capacity and filled with a copy of the range.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>.<br>
                <code>first</code> and <code>last</code> have to meet the requirements of <a href=
                "http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> ==
                buffer_capacity &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> &lt;=
                std::distance(first, last) &amp;&amp; (*this)[0]== *(last - buffer_capacity) &amp;&amp; (*this)[1] ==
                *(last - buffer_capacity + 1) &amp;&amp; ... &amp;&amp; (*this)[buffer_capacity - 1] == *(last -
                1)</code><br>
                <br>
                If the number of items to be copied from the range <code>[first, last)</code> is greater than the
                specified <code>buffer_capacity</code> then only elements from the range <code>[last - buffer_capacity,
                last)</code> will be copied.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>buffer_capacity</code>
                  </dt>
                  <dd>
                    The capacity of the created <code>circular_buffer</code>.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>first</code>
                  </dt>
                  <dd>
                    The beginning of the range to be copied.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>last</code>
                  </dt>
                  <dd>
                    The end of the range to be copied.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>alloc</code>
                  </dt>
                  <dd>
                    The allocator.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>std::distance(first, last)</code>; in <code>min[capacity, std::distance(first,
                last)]</code> if the <code>InputIterator</code> is a <a href=
                "http://www.sgi.com/tech/stl/RandomAccessIterator.html">RandomAccessIterator</a>).
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_164250ffbbbdbc62b99e8301fc195b80c" name=
            "classboost_1_1circular__buffer_164250ffbbbdbc62b99e8301fc195b80c"></a><code><b>~circular_buffer();</b></code><br>

            <br>
            The destructor.
            <p>
              Destroys the <code>circular_buffer</code>.
            </p>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (including iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>) for scalar types; linear for other types.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e">clear()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="methods" id="methods">Public Member Functions</a>
    </h2>
    <div id="srcdoc_methods">
      <table id="table_methods" border="1" cellpadding="3">
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1a20b7d0e7a4da0af13286df9f53d660c" name=
            "classboost_1_1circular__buffer_1a20b7d0e7a4da0af13286df9f53d660c"></a><code><b><a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a> get_allocator()
            const;</b></code><br>
            <br>
            Get the allocator.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                The allocator.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_1af7758a36ac2f84a3024b50b4fc7e098">get_allocator()</a></code> for
                obtaining an allocator reference.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1af7758a36ac2f84a3024b50b4fc7e098" name=
            "classboost_1_1circular__buffer_1af7758a36ac2f84a3024b50b4fc7e098"></a><code><b><a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp;
            get_allocator();</b></code><br>
            <br>
            Get the allocator reference.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A reference to the allocator.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                This method was added in order to optimize obtaining of the allocator with a state, although use of
                stateful allocators in STL is discouraged.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1a20b7d0e7a4da0af13286df9f53d660c">get_allocator()
                const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0" name=
            "classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> begin();</b></code><br>
            <br>
            Get the iterator pointing to the beginning of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A random access iterator pointing to the first element of the <code>circular_buffer</code>. If the
                <code>circular_buffer</code> is empty it returns an iterator equal to the one returned by
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa">rbegin()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697">rend()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1" name=
            "classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> end();</b></code><br>
            <br>
            Get the iterator pointing to the end of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A random access iterator pointing to the element "one behind" the last element of the
                <code>circular_buffer</code>. If the <code>circular_buffer</code> is empty it returns an iterator equal
                to the one returned by <code><a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a></code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa">rbegin()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697">rend()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038" name=
            "classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038"></a><code><b><a href=
            "#classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9">const_iterator</a> begin()
            const;</b></code><br>
            <br>
            Get the const iterator pointing to the beginning of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A const random access iterator pointing to the first element of the <code>circular_buffer</code>. If
                the <code>circular_buffer</code> is empty it returns an iterator equal to the one returned by
                <code><a href="#classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac">end()
                const</a></code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac">end()
                const</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026">rbegin() const</a></code>,
                <code><a href="#classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3">rend()
                const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac" name=
            "classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac"></a><code><b><a href=
            "#classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9">const_iterator</a> end()
            const;</b></code><br>
            <br>
            Get the const iterator pointing to the end of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A const random access iterator pointing to the element "one behind" the last element of the
                <code>circular_buffer</code>. If the <code>circular_buffer</code> is empty it returns an iterator equal
                to the one returned by <code><a href=
                "#classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038">begin() const</a></code> const.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038">begin()
                const</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026">rbegin() const</a></code>,
                <code><a href="#classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3">rend()
                const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa" name=
            "classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1002fb890dded89e75dfeb6f021fb58a5">reverse_iterator</a>
            rbegin();</b></code><br>
            <br>
            Get the iterator pointing to the beginning of the "reversed" <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A reverse random access iterator pointing to the last element of the <code>circular_buffer</code>. If
                the <code>circular_buffer</code> is empty it returns an iterator equal to the one returned by
                <code><a href="#classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697">rend()</a></code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697">rend()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697" name=
            "classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1002fb890dded89e75dfeb6f021fb58a5">reverse_iterator</a>
            rend();</b></code><br>
            <br>
            Get the iterator pointing to the end of the "reversed" <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A reverse random access iterator pointing to the element "one before" the first element of the
                <code>circular_buffer</code>. If the <code>circular_buffer</code> is empty it returns an iterator equal
                to the one returned by <code><a href=
                "#classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa">rbegin()</a></code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa">rbegin()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026" name=
            "classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1c7317701b511bc5f7a663b06b53e2b73">const_reverse_iterator</a> rbegin()
            const;</b></code><br>
            <br>
            Get the const iterator pointing to the beginning of the "reversed" <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A const reverse random access iterator pointing to the last element of the
                <code>circular_buffer</code>. If the <code>circular_buffer</code> is empty it returns an iterator equal
                to the one returned by <code><a href=
                "#classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3">rend() const</a></code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3">rend()
                const</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038">begin() const</a></code>,
                <code><a href="#classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac">end()
                const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3" name=
            "classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1c7317701b511bc5f7a663b06b53e2b73">const_reverse_iterator</a> rend()
            const;</b></code><br>
            <br>
            Get the const iterator pointing to the end of the "reversed" <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A const reverse random access iterator pointing to the element "one before" the first element of the
                <code>circular_buffer</code>. If the <code>circular_buffer</code> is empty it returns an iterator equal
                to the one returned by <code><a href=
                "#classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026">rbegin() const</a></code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026">rbegin()
                const</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038">begin() const</a></code>,
                <code><a href="#classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac">end()
                const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1d219f0d3203fb43b964a8cf63f1865cd" name=
            "classboost_1_1circular__buffer_1d219f0d3203fb43b964a8cf63f1865cd"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a> operator[](<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> index);</b></code><br>
            <br>
            Get the element at the <code>index</code> position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>0 &lt;= index &amp;&amp; index &lt; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>index</code>
                  </dt>
                  <dd>
                    The position of the element.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A reference to the element at the <code>index</code> position.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1cd84838cb4fffb6c113fd0297e502edc">at()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1eb0a7fe7f8a56a4dc4c933b93adfcef4" name=
            "classboost_1_1circular__buffer_1eb0a7fe7f8a56a4dc4c933b93adfcef4"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> operator[](<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> index)
            const;</b></code><br>
            <br>
            Get the element at the <code>index</code> position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>0 &lt;= index &amp;&amp; index &lt; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>index</code>
                  </dt>
                  <dd>
                    The position of the element.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A const reference to the element at the <code>index</code> position.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1b233a298f5845a0fcf2ecc56f4170810">at() const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1cd84838cb4fffb6c113fd0297e502edc" name=
            "classboost_1_1circular__buffer_1cd84838cb4fffb6c113fd0297e502edc"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a> at(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> index);</b></code><br>
            <br>
            Get the element at the <code>index</code> position.
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>index</code>
                  </dt>
                  <dd>
                    The position of the element.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A reference to the element at the <code>index</code> position.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <code>std::out_of_range</code> when the <code>index</code> is invalid (when <code>index &gt;= <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Strong.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1d219f0d3203fb43b964a8cf63f1865cd">operator[]</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b233a298f5845a0fcf2ecc56f4170810" name=
            "classboost_1_1circular__buffer_1b233a298f5845a0fcf2ecc56f4170810"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> at(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> index)
            const;</b></code><br>
            <br>
            Get the element at the <code>index</code> position.
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>index</code>
                  </dt>
                  <dd>
                    The position of the element.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A const reference to the element at the <code>index</code> position.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <code>std::out_of_range</code> when the <code>index</code> is invalid (when <code>index &gt;= <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Strong.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1eb0a7fe7f8a56a4dc4c933b93adfcef4">operator[]
                const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10d5fdeabeb352f47d1f7bb1ea8d9819f" name=
            "classboost_1_1circular__buffer_10d5fdeabeb352f47d1f7bb1ea8d9819f"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a> front();</b></code><br>
            <br>
            Get the first element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!empty()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A reference to the first element of the <code>circular_buffer</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1d985d974020f88bb4255d8edbae0a30a">back()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1d985d974020f88bb4255d8edbae0a30a" name=
            "classboost_1_1circular__buffer_1d985d974020f88bb4255d8edbae0a30a"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a> back();</b></code><br>
            <br>
            Get the last element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!empty()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A reference to the last element of the <code>circular_buffer</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_10d5fdeabeb352f47d1f7bb1ea8d9819f">front()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10df8595d83bb9d8a7ce50aabc678f90b" name=
            "classboost_1_1circular__buffer_10df8595d83bb9d8a7ce50aabc678f90b"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> front()
            const;</b></code><br>
            <br>
            Get the first element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!empty()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A const reference to the first element of the <code>circular_buffer</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1027201797868c6274feb6712f670a132">back()
                const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1027201797868c6274feb6712f670a132" name=
            "classboost_1_1circular__buffer_1027201797868c6274feb6712f670a132"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> back()
            const;</b></code><br>
            <br>
            Get the last element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!empty()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A const reference to the last element of the <code>circular_buffer</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_10df8595d83bb9d8a7ce50aabc678f90b">front()
                const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d" name=
            "classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d"></a><code><b><a href=
            "#classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f">array_range</a>
            array_one();</b></code><br>
            <br>
            Get the first continuous array of the internal buffer.
            <p>
              This method in combination with <code><a href=
              "#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two()</a></code> can be useful
              when passing the stored data into a legacy C API as an array. Suppose there is a
              <code>circular_buffer</code> of capacity 10, containing 7 characters <code>'a', 'b', ..., 'g'</code>
              where <code>buff[0] == 'a'</code>, <code>buff[1] == 'b'</code>, ... and <code>buff[6] == 'g'</code>:<br>
              <br>
              <code>circular_buffer&lt;char&gt; buff(10);</code><br>
              <br>
              The internal representation is often not linear and the state of the internal buffer may look like
              this:<br>
              <br>
              <code>|e|f|g| | | |a|b|c|d|<br>
              end ---^<br>
              begin -------^</code><br>
              <br>
              where <code>|a|b|c|d|</code> represents the "array one", <code>|e|f|g|</code> represents the "array two"
              and <code>| | | |</code> is a free space.<br>
              Now consider a typical C style function for writing data into a file:<br>
              <br>
              <code>int write(int file_desc, char* buff, int num_bytes);</code><br>
              <br>
              There are two ways how to write the content of the <code>circular_buffer</code> into a file. Either
              relying on <code><a href=
              "#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one()</a></code> and
              <code><a href="#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two()</a></code>
              methods and calling the write function twice:<br>
              <br>
              <code>array_range ar = buff.array_one();<br>
              write(file_desc, ar.first, ar.second);<br>
              ar = buff.array_two();<br>
              write(file_desc, ar.first, ar.second);</code><br>
              <br>
              Or relying on the <code><a href=
              "#classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e">linearize()</a></code> method:<br>
              <br>
              <code>write(file_desc, buff.linearize(), buff.size());</code><br>
              <br>
              Since the complexity of <code><a href=
              "#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one()</a></code> and
              <code><a href="#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two()</a></code>
              methods is constant the first option is suitable when calling the write method is "cheap". On the other
              hand the second option is more suitable when calling the write method is more "expensive" than calling
              the <code><a href=
              "#classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e">linearize()</a></code> method whose
              complexity is linear.
            </p>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                The array range of the first continuous array of the internal buffer. In the case the
                <code>circular_buffer</code> is empty the size of the returned array is <code>0</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Warning:</b>
              </dt>
              <dd>
                In general invoking any method which modifies the internal state of the circular_buffer may delinearize
                the internal buffer and invalidate the array ranges returned by <code><a href=
                "#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one()</a></code> and
                <code><a href=
                "#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two()</a></code> (and their
                const versions).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                In the case the internal buffer is linear e.g. <code>|a|b|c|d|e|f|g| | | |</code> the "array one" is
                represented by <code>|a|b|c|d|e|f|g|</code> and the "array two" does not exist (the <code><a href=
                "#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two()</a></code> method
                returns an array with the size <code>0</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e">linearize()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b" name=
            "classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b"></a><code><b><a href=
            "#classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f">array_range</a>
            array_two();</b></code><br>
            <br>
            Get the second continuous array of the internal buffer.
            <p>
              This method in combination with <code><a href=
              "#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one()</a></code> can be useful
              when passing the stored data into a legacy C API as an array.
            </p>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                The array range of the second continuous array of the internal buffer. In the case the internal buffer
                is linear or the <code>circular_buffer</code> is empty the size of the returned array is
                <code>0</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10f4b157e27b1170a571417986b239945" name=
            "classboost_1_1circular__buffer_10f4b157e27b1170a571417986b239945"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025">const_array_range</a> array_one()
            const;</b></code><br>
            <br>
            Get the first continuous array of the internal buffer.
            <p>
              This method in combination with <code><a href=
              "#classboost_1_1circular__buffer_1bb8eb0f298ad2012c55c5303e1f174d5">array_two() const</a></code> can be
              useful when passing the stored data into a legacy C API as an array.
            </p>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                The array range of the first continuous array of the internal buffer. In the case the
                <code>circular_buffer</code> is empty the size of the returned array is <code>0</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1bb8eb0f298ad2012c55c5303e1f174d5">array_two()
                const</a></code>; <code><a href=
                "#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one()</a></code> for more
                details how to pass data into a legacy C API.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1bb8eb0f298ad2012c55c5303e1f174d5" name=
            "classboost_1_1circular__buffer_1bb8eb0f298ad2012c55c5303e1f174d5"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025">const_array_range</a> array_two()
            const;</b></code><br>
            <br>
            Get the second continuous array of the internal buffer.
            <p>
              This method in combination with <code><a href=
              "#classboost_1_1circular__buffer_10f4b157e27b1170a571417986b239945">array_one() const</a></code> can be
              useful when passing the stored data into a legacy C API as an array.
            </p>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                The array range of the second continuous array of the internal buffer. In the case the internal buffer
                is linear or the <code>circular_buffer</code> is empty the size of the returned array is
                <code>0</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_10f4b157e27b1170a571417986b239945">array_one()
                const</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e" name=
            "classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e"></a><code><b><a href=
            "#classboost_1_1circular__buffer_14ff917f8a6131ec18e91606727592a9c">pointer</a> linearize();</b></code><br>
            <br>
            Linearize the internal buffer into a continuous array.
            <p>
              This method can be useful when passing the stored data into a legacy C API as an array.
            </p>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code>&amp;(*this)[0] &lt; &amp;(*this)[1] &lt; ... &lt; &amp;(*this)[<a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> - 1]</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A pointer to the beginning of the array or <code>0</code> if empty.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operations in the <i>Throws</i> section do not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>);
                does not invalidate any iterators if the postcondition (the <i>Effect</i>) is already met prior calling
                this method.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the size of the <code>circular_buffer</code>); constant if the postcondition (the
                <i>Effect</i>) is already met.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Warning:</b>
              </dt>
              <dd>
                In general invoking any method which modifies the internal state of the <code>circular_buffer</code>
                may delinearize the internal buffer and invalidate the returned pointer.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one()</a></code> and
                <code><a href=
                "#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two()</a></code> for the
                other option how to pass data into a legacy C API; <code><a href=
                "#classboost_1_1circular__buffer_120f64448dc0723cc68c1096f6b00bc0a">is_linearized()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1c591bb9e271b10b5240afcff3bd2c619">rotate(const_iterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_120f64448dc0723cc68c1096f6b00bc0a" name=
            "classboost_1_1circular__buffer_120f64448dc0723cc68c1096f6b00bc0a"></a><code><b>bool is_linearized()
            const;</b></code><br>
            <br>
            Is the <code>circular_buffer</code> linearized?
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>true</code> if the internal buffer is linearized into a continuous array (i.e. the
                <code>circular_buffer</code> meets a condition <code>&amp;(*this)[0] &lt; &amp;(*this)[1] &lt; ... &lt;
                &amp;(*this)[<a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> -
                1]</code>); <code>false</code> otherwise.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e">linearize()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1c591bb9e271b10b5240afcff3bd2c619" name=
            "classboost_1_1circular__buffer_1c591bb9e271b10b5240afcff3bd2c619"></a><code><b>void rotate(<a href=
            "#classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9">const_iterator</a>
            new_begin);</b></code><br>
            <br>
            Rotate elements in the <code>circular_buffer</code>.
            <p>
              A more effective implementation of <code><a href=
              "http://www.sgi.com/tech/stl/rotate.html">std::rotate</a></code>.
            </p>
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>new_begin</code> is a valid iterator pointing to the <code>circular_buffer</code> <b>except</b>
                its end.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                Before calling the method suppose:<br>
                <br>
                <code>m == std::distance(new_begin, <a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>)</code><br>
                <code>n == std::distance(<a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, new_begin)</code><br>
                <code>val_0 == *new_begin, val_1 == *(new_begin + 1), ... val_m == *(new_begin + m)</code><br>
                <code>val_r1 == *(new_begin - 1), val_r2 == *(new_begin - 2), ... val_rn == *(new_begin - n)</code><br>
                <br>
                then after call to the method:<br>
                <br>
                <code>val_0 == (*this)[0] &amp;&amp; val_1 == (*this)[1] &amp;&amp; ... &amp;&amp; val_m == (*this)[m -
                1] &amp;&amp; val_r1 == (*this)[m + n - 1] &amp;&amp; val_r2 == (*this)[m + n - 2] &amp;&amp; ...
                &amp;&amp; val_rn == (*this)[m]</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>new_begin</code>
                  </dt>
                  <dd>
                    The new beginning.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the <code>circular_buffer</code> is full or <code>new_begin</code> points to
                <code><a href="#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a></code> or
                if the operations in the <i>Throws</i> section do not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                If <code>m &lt; n</code> invalidates iterators pointing to the last <code>m</code> elements
                (<b>including</b> <code>new_begin</code>, but not iterators equal to <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>) else invalidates
                iterators pointing to the first <code>n</code> elements; does not invalidate any iterators if the
                <code>circular_buffer</code> is full.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>(std::min)(m, n)</code>); constant if the <code>circular_buffer</code> is full.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="http://www.sgi.com/tech/stl/rotate.html">std::rotate</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32" name=
            "classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32"></a><code><b><a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> size()
            const;</b></code><br>
            <br>
            Get the number of elements currently stored in the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                The number of elements stored in the <code>circular_buffer</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_157e2d506bc274b2a63fbe1b8fcafebd7">max_size()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_180c2e2e66a8fa9d0b7adc1b54921a8c3">resize(size_type,
                const_reference)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_157e2d506bc274b2a63fbe1b8fcafebd7" name=
            "classboost_1_1circular__buffer_157e2d506bc274b2a63fbe1b8fcafebd7"></a><code><b><a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> max_size()
            const;</b></code><br>
            <br>
            Get the largest possible size or capacity of the <code>circular_buffer</code>. (It depends on allocator's
            max_size()).
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                The maximum size/capacity the <code>circular_buffer</code> can be set to.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15be1c2a005ec9828549ef6dd7ebed583" name=
            "classboost_1_1circular__buffer_15be1c2a005ec9828549ef6dd7ebed583"></a><code><b>bool empty()
            const;</b></code><br>
            <br>
            Is the <code>circular_buffer</code> empty?
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>true</code> if there are no elements stored in the <code>circular_buffer</code>;
                <code>false</code> otherwise.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1fd0eef8ba91210d1575404b7e3e8207a">full()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1fd0eef8ba91210d1575404b7e3e8207a" name=
            "classboost_1_1circular__buffer_1fd0eef8ba91210d1575404b7e3e8207a"></a><code><b>bool full()
            const;</b></code><br>
            <br>
            Is the <code>circular_buffer</code> full?
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>true</code> if the number of elements stored in the <code>circular_buffer</code> equals the
                capacity of the <code>circular_buffer</code>; <code>false</code> otherwise.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15be1c2a005ec9828549ef6dd7ebed583">empty()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de" name=
            "classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de"></a><code><b><a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> reserve()
            const;</b></code><br>
            <br>
            Get the maximum number of elements which can be inserted into the <code>circular_buffer</code> without
            overwriting any of already stored elements.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> -
                <a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_157e2d506bc274b2a63fbe1b8fcafebd7">max_size()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77" name=
            "classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595">capacity_type</a> capacity()
            const;</b></code><br>
            <br>
            Get the capacity of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                The maximum number of elements which can be stored in the <code>circular_buffer</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a></code>,
                <code><a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_157e2d506bc274b2a63fbe1b8fcafebd7">max_size()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_161714204ef5172d156e2c7eccd04998f">set_capacity(capacity_type)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_161714204ef5172d156e2c7eccd04998f" name=
            "classboost_1_1circular__buffer_161714204ef5172d156e2c7eccd04998f"></a><code><b>void set_capacity(<a href=
            "#classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595">capacity_type</a>
            new_capacity);</b></code><br>
            <br>
            Change the capacity of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> ==
                new_capacity &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> &lt;=
                new_capacity</code><br>
                <br>
                If the current number of elements stored in the <code>circular_buffer</code> is greater than the
                desired new capacity then number of <code>[<a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> - new_capacity]</code>
                <b>last</b> elements will be removed and the new size will be equal to <code>new_capacity</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>new_capacity</code>
                  </dt>
                  <dd>
                    The new capacity.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Strong.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>) if
                the new capacity is different from the original.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>min[<a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a>, new_capacity]</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_1477715e9d31d2cc5b02ad8ecf3c68c46">rset_capacity(capacity_type)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_180c2e2e66a8fa9d0b7adc1b54921a8c3">resize(size_type,
                const_reference)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_180c2e2e66a8fa9d0b7adc1b54921a8c3" name=
            "classboost_1_1circular__buffer_180c2e2e66a8fa9d0b7adc1b54921a8c3"></a><code><b>void resize(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> new_size, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> item =
            value_type());</b></code><br>
            <br>
            Change the size of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> ==
                new_size &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> &gt;=
                new_size</code><br>
                <br>
                If the new size is greater than the current size, copies of <code>item</code> will be inserted at the
                <b>back</b> of the of the <code>circular_buffer</code> in order to achieve the desired size. In the
                case the resulting size exceeds the current capacity the capacity will be set to
                <code>new_size</code>.<br>
                If the current number of elements stored in the <code>circular_buffer</code> is greater than the
                desired new size then number of <code>[<a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> - new_size]</code>
                <b>last</b> elements will be removed. (The capacity will remain unchanged.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>new_size</code>
                  </dt>
                  <dd>
                    The new size.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element the <code>circular_buffer</code> will be filled with in order to gain the requested
                    size. (See the <i>Effect</i>.)
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>) if
                the new size is greater than the current capacity. Invalidates iterators pointing to the removed
                elements if the new size is lower that the original size. Otherwise it does not invalidate any
                iterator.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the new size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_144ecd9ec5f54a2d61c7d132e445d3483">rresize(size_type,
                const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_161714204ef5172d156e2c7eccd04998f">set_capacity(capacity_type)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1477715e9d31d2cc5b02ad8ecf3c68c46" name=
            "classboost_1_1circular__buffer_1477715e9d31d2cc5b02ad8ecf3c68c46"></a><code><b>void rset_capacity(<a href=
            "#classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595">capacity_type</a>
            new_capacity);</b></code><br>
            <br>
            Change the capacity of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> ==
                new_capacity &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> &lt;=
                new_capacity</code><br>
                <br>
                If the current number of elements stored in the <code>circular_buffer</code> is greater than the
                desired new capacity then number of <code>[<a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> - new_capacity]</code>
                <b>first</b> elements will be removed and the new size will be equal to <code>new_capacity</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>new_capacity</code>
                  </dt>
                  <dd>
                    The new capacity.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Strong.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>) if
                the new capacity is different from the original.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>min[<a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a>, new_capacity]</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_161714204ef5172d156e2c7eccd04998f">set_capacity(capacity_type)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_144ecd9ec5f54a2d61c7d132e445d3483">rresize(size_type,
                const_reference)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_144ecd9ec5f54a2d61c7d132e445d3483" name=
            "classboost_1_1circular__buffer_144ecd9ec5f54a2d61c7d132e445d3483"></a><code><b>void rresize(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> new_size, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> item =
            value_type());</b></code><br>
            <br>
            Change the size of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> ==
                new_size &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> &gt;=
                new_size</code><br>
                <br>
                If the new size is greater than the current size, copies of <code>item</code> will be inserted at the
                <b>front</b> of the of the <code>circular_buffer</code> in order to achieve the desired size. In the
                case the resulting size exceeds the current capacity the capacity will be set to
                <code>new_size</code>.<br>
                If the current number of elements stored in the <code>circular_buffer</code> is greater than the
                desired new size then number of <code>[<a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> - new_size]</code>
                <b>first</b> elements will be removed. (The capacity will remain unchanged.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>new_size</code>
                  </dt>
                  <dd>
                    The new size.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element the <code>circular_buffer</code> will be filled with in order to gain the requested
                    size. (See the <i>Effect</i>.)
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>) if
                the new size is greater than the current capacity. Invalidates iterators pointing to the removed
                elements if the new size is lower that the original size. Otherwise it does not invalidate any
                iterator.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the new size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_180c2e2e66a8fa9d0b7adc1b54921a8c3">resize(size_type,
                const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1477715e9d31d2cc5b02ad8ecf3c68c46">rset_capacity(capacity_type)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d" name=
            "classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d"></a><code><b>circular_buffer&lt;T,Alloc&gt;&amp;
            operator=(const circular_buffer&lt;T,Alloc&gt;&amp; cb);</b></code><br>
            <br>
            The assign operator.
            <p>
              Makes this <code>circular_buffer</code> to become a copy of the specified <code>circular_buffer</code>.
            </p>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code>*this == cb</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>cb</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to be copied.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Strong.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to this <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the size of <code>cb</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada">assign(size_type,
                const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1dbebb80a5f38e52a37ec9f3ed765600a">assign(capacity_type, size_type,
                const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c">assign(InputIterator,
                InputIterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_127cab6034beeeb0e11863c8c14d14366">assign(capacity_type,
                InputIterator, InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada" name=
            "classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada"></a><code><b>void assign(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a>
            item);</b></code><br>
            <br>
            Assign <code>n</code> items into the <code>circular_buffer</code>.
            <p>
              The content of the <code>circular_buffer</code> will be removed and replaced with <code>n</code> copies
              of the <code>item</code>.
            </p>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> == n
                &amp;&amp; <a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> == n
                &amp;&amp; (*this)[0] == item &amp;&amp; (*this)[1] == item &amp;&amp; ... &amp;&amp; (*this) [n - 1]
                == item</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>n</code>
                  </dt>
                  <dd>
                    The number of elements the <code>circular_buffer</code> will be filled with.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element the <code>circular_buffer</code> will be filled with.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the <code>n</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d">operator=</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1dbebb80a5f38e52a37ec9f3ed765600a">assign(capacity_type,
                size_type, const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c">assign(InputIterator,
                InputIterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_127cab6034beeeb0e11863c8c14d14366">assign(capacity_type,
                InputIterator, InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1dbebb80a5f38e52a37ec9f3ed765600a" name=
            "classboost_1_1circular__buffer_1dbebb80a5f38e52a37ec9f3ed765600a"></a><code><b>void assign(<a href=
            "#classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595">capacity_type</a> buffer_capacity,
            <a href="#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a>
            item);</b></code><br>
            <br>
            Assign <code>n</code> items into the <code>circular_buffer</code> specifying the capacity.
            <p>
              The capacity of the <code>circular_buffer</code> will be set to the specified value and the content of
              the <code>circular_buffer</code> will be removed and replaced with <code>n</code> copies of the
              <code>item</code>.
            </p>
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>capacity &gt;= n</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> ==
                buffer_capacity &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> == n &amp;&amp;
                (*this)[0] == item &amp;&amp; (*this)[1] == item &amp;&amp; ... &amp;&amp; (*this) [n - 1] ==
                item</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>buffer_capacity</code>
                  </dt>
                  <dd>
                    The new capacity.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>n</code>
                  </dt>
                  <dd>
                    The number of elements the <code>circular_buffer</code> will be filled with.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element the <code>circular_buffer</code> will be filled with.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the <code>n</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d">operator=</a></code>,
                <code><a href="#classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada">assign(size_type,
                const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c">assign(InputIterator,
                InputIterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_127cab6034beeeb0e11863c8c14d14366">assign(capacity_type,
                InputIterator, InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c" name=
            "classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                void assign(InputIterator first, InputIterator last);</b></code><br>
            <br>
            Assign a copy of the range into the <code>circular_buffer</code>.
            <p>
              The content of the <code>circular_buffer</code> will be removed and replaced with copies of elements from
              the specified range.
            </p>
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>.<br>
                <code>first</code> and <code>last</code> have to meet the requirements of <a href=
                "http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> ==
                std::distance(first, last) &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> == std::distance(first,
                last) &amp;&amp; (*this)[0]== *first &amp;&amp; (*this)[1] == *(first + 1) &amp;&amp; ... &amp;&amp;
                (*this)[std::distance(first, last) - 1] == *(last - 1)</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>first</code>
                  </dt>
                  <dd>
                    The beginning of the range to be copied.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>last</code>
                  </dt>
                  <dd>
                    The end of the range to be copied.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the <code>std::distance(first, last)</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d">operator=</a></code>,
                <code><a href="#classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada">assign(size_type,
                const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1dbebb80a5f38e52a37ec9f3ed765600a">assign(capacity_type, size_type,
                const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_127cab6034beeeb0e11863c8c14d14366">assign(capacity_type,
                InputIterator, InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_127cab6034beeeb0e11863c8c14d14366" name=
            "classboost_1_1circular__buffer_127cab6034beeeb0e11863c8c14d14366"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                void assign(<a href=
            "#classboost_1_1circular__buffer_1dc642ff2be4db0be1a457810e5d09595">capacity_type</a> buffer_capacity,
            InputIterator first, InputIterator last);</b></code><br>
            <br>
            Assign a copy of the range into the <code>circular_buffer</code> specifying the capacity.
            <p>
              The capacity of the <code>circular_buffer</code> will be set to the specified value and the content of
              the <code>circular_buffer</code> will be removed and replaced with copies of elements from the specified
              range.
            </p>
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>.<br>
                <code>first</code> and <code>last</code> have to meet the requirements of <a href=
                "http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a> ==
                buffer_capacity &amp;&amp; <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> &lt;=
                std::distance(first, last) &amp;&amp; (*this)[0]== *(last - buffer_capacity) &amp;&amp; (*this)[1] ==
                *(last - buffer_capacity + 1) &amp;&amp; ... &amp;&amp; (*this)[buffer_capacity - 1] == *(last -
                1)</code><br>
                <br>
                If the number of items to be copied from the range <code>[first, last)</code> is greater than the
                specified <code>buffer_capacity</code> then only elements from the range <code>[last - buffer_capacity,
                last)</code> will be copied.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>buffer_capacity</code>
                  </dt>
                  <dd>
                    The new capacity.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>first</code>
                  </dt>
                  <dd>
                    The beginning of the range to be copied.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>last</code>
                  </dt>
                  <dd>
                    The end of the range to be copied.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                An allocation error if memory is exhausted (<code>std::bad_alloc</code> if the standard allocator is
                used).
              </dd>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>std::distance(first, last)</code>; in <code>min[capacity, std::distance(first,
                last)]</code> if the <code>InputIterator</code> is a <a href=
                "http://www.sgi.com/tech/stl/RandomAccessIterator.html">RandomAccessIterator</a>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d">operator=</a></code>,
                <code><a href="#classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada">assign(size_type,
                const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1dbebb80a5f38e52a37ec9f3ed765600a">assign(capacity_type, size_type,
                const_reference)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c">assign(InputIterator,
                InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1270ab7074c365663a6f18808024fd88b" name=
            "classboost_1_1circular__buffer_1270ab7074c365663a6f18808024fd88b"></a><code><b>void
            swap(circular_buffer&lt;T,Alloc&gt;&amp; cb);</b></code><br>
            <br>
            Swap the contents of two <code>circular_buffer</code>s.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code>this</code> contains elements of <code>cb</code> and vice versa; the capacity of
                <code>this</code> equals to the capacity of <code>cb</code> and vice versa.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>cb</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> whose content will be swapped.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators of both <code>circular_buffer</code>s. (On the other hand the iterators still
                point to the same elements but within another container. If you want to rely on this feature you have
                to turn the <a href="#debug">Debug Support</a> off otherwise an assertion will report an error if such
                invalidated iterator is used.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#namespaceboost_14aa8f6a2c9640f3f22e266f0fca85777">swap(circular_buffer&lt;T,
                Alloc&gt;&amp;, circular_buffer&lt;T, Alloc&gt;&amp;)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e" name=
            "classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e"></a><code><b>void push_back(<a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> item =
            value_type());</b></code><br>
            <br>
            Insert a new element at the end of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                if <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a>
                &gt; 0</code> then <code><a href=
                "#classboost_1_1circular__buffer_1d985d974020f88bb4255d8edbae0a30a">back()</a> == item</code><br>
                If the <code>circular_buffer</code> is full, the first element will be removed. If the capacity is
                <code>0</code>, nothing will be inserted.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element to be inserted.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operation in the <i>Throws</i> section does not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators with the exception of iterators pointing to the overwritten element.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_10ef57e73c193682a649d8eb4a1096dce">push_front(const_reference)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1df0da00cb501bea75afbbfab9f546a07">pop_back()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_18ac972dc24ef7236faa1875de92b9dd8">pop_front()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10ef57e73c193682a649d8eb4a1096dce" name=
            "classboost_1_1circular__buffer_10ef57e73c193682a649d8eb4a1096dce"></a><code><b>void push_front(<a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> item =
            value_type());</b></code><br>
            <br>
            Insert a new element at the beginning of the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                if <code><a href="#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a>
                &gt; 0</code> then <code><a href=
                "#classboost_1_1circular__buffer_10d5fdeabeb352f47d1f7bb1ea8d9819f">front()</a> == item</code><br>
                If the <code>circular_buffer</code> is full, the last element will be removed. If the capacity is
                <code>0</code>, nothing will be inserted.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element to be inserted.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operation in the <i>Throws</i> section does not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators with the exception of iterators pointing to the overwritten element.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e">push_back(const_reference)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1df0da00cb501bea75afbbfab9f546a07">pop_back()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_18ac972dc24ef7236faa1875de92b9dd8">pop_front()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1df0da00cb501bea75afbbfab9f546a07" name=
            "classboost_1_1circular__buffer_1df0da00cb501bea75afbbfab9f546a07"></a><code><b>void
            pop_back();</b></code><br>
            <br>
            Remove the last element from the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!empty()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The last element is removed from the <code>circular_buffer</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates only iterators pointing to the removed element.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_18ac972dc24ef7236faa1875de92b9dd8">pop_front()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e">push_back(const_reference)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_10ef57e73c193682a649d8eb4a1096dce">push_front(const_reference)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_18ac972dc24ef7236faa1875de92b9dd8" name=
            "classboost_1_1circular__buffer_18ac972dc24ef7236faa1875de92b9dd8"></a><code><b>void
            pop_front();</b></code><br>
            <br>
            Remove the first element from the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!empty()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The first element is removed from the <code>circular_buffer</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates only iterators pointing to the removed element.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_1df0da00cb501bea75afbbfab9f546a07">pop_back()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e">push_back(const_reference)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_10ef57e73c193682a649d8eb4a1096dce">push_front(const_reference)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95" name=
            "classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> insert(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> item =
            value_type());</b></code><br>
            <br>
            Insert an element at the specified position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>pos</code> is a valid iterator pointing to the <code>circular_buffer</code> or its end.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The <code>item</code> will be inserted at the position <code>pos</code>.<br>
                If the <code>circular_buffer</code> is full, the first element will be overwritten. If the
                <code>circular_buffer</code> is full and the <code>pos</code> points to <code><a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a></code>, then the
                <code>item</code> will not be inserted. If the capacity is <code>0</code>, nothing will be inserted.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>pos</code>
                  </dt>
                  <dd>
                    An iterator specifying the position where the <code>item</code> will be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element to be inserted.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                Iterator to the inserted element or <code><a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a></code> if the
                <code>item</code> is not inserted. (See the <i>Effect</i>.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operation in the <i>Throws</i> section does not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the elements at the insertion point (including <code>pos</code>) and
                iterators behind the insertion point (towards the end; except iterators equal to <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>). It also
                invalidates iterators pointing to the overwritten element.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>std::distance(pos, <a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>)</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140">insert(iterator,
                size_type, value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6">insert(iterator, InputIterator,
                InputIterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c">rinsert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5">rinsert(iterator, size_type,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323">rinsert(iterator, InputIterator,
                InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140" name=
            "classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140"></a><code><b>void insert(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos, <a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a>
            item);</b></code><br>
            <br>
            Insert <code>n</code> copies of the <code>item</code> at the specified position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>pos</code> is a valid iterator pointing to the <code>circular_buffer</code> or its end.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The number of <code>min[n, (pos - <a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>) + <a href=
                "#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a>]</code> elements will
                be inserted at the position <code>pos</code>.<br>
                The number of <code>min[pos - <a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, max[0, n - <a href=
                "#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a>]]</code> elements
                will be overwritten at the beginning of the <code>circular_buffer</code>.<br>
                (See <i>Example</i> for the explanation.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>pos</code>
                  </dt>
                  <dd>
                    An iterator specifying the position where the <code>item</code>s will be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>n</code>
                  </dt>
                  <dd>
                    The number of <code>item</code>s the to be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element whose copies will be inserted.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operations in the <i>Throws</i> section do not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the elements at the insertion point (including <code>pos</code>) and
                iterators behind the insertion point (towards the end; except iterators equal to <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>). It also
                invalidates iterators pointing to the overwritten elements.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>min[<a href=
                "#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a>, std::distance(pos,
                <a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>) + n]</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Example:</b>
              </dt>
              <dd>
                Consider a <code>circular_buffer</code> with the capacity of 6 and the size of 4. Its internal buffer
                may look like the one below.<br>
                <br>
                <code>|1|2|3|4| | |</code><br>
                <code>p ---^</code><br>
                <br>
                After inserting 5 elements at the position <code>p</code>:<br>
                <br>
                <code>insert(p, (size_t)5, 0);</code><br>
                <br>
                actually only 4 elements get inserted and elements <code>1</code> and <code>2</code> are overwritten.
                This is due to the fact the insert operation preserves the capacity. After insertion the internal
                buffer looks like this:<br>
                <br>
                <code>|0|0|0|0|3|4|</code><br>
                <br>
                For comparison if the capacity would not be preserved the internal buffer would then result in
                <code>|1|2|0|0|0|0|0|3|4|</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95">insert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6">insert(iterator, InputIterator,
                InputIterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c">rinsert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5">rinsert(iterator, size_type,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323">rinsert(iterator, InputIterator,
                InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6" name=
            "classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                void insert(<a href="#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a>
            pos, InputIterator first, InputIterator last);</b></code><br>
            <br>
            Insert the range <code>[first, last)</code> at the specified position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>pos</code> is a valid iterator pointing to the <code>circular_buffer</code> or its end.<br>
                Valid range <code>[first, last)</code> where <code>first</code> and <code>last</code> meet the
                requirements of an <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                Elements from the range <code>[first + max[0, distance(first, last) - (pos - <a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>) - <a href=
                "#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a>], last)</code> will
                be inserted at the position <code>pos</code>.<br>
                The number of <code>min[pos - <a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, max[0, distance(first,
                last) - <a href=
                "#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a>]]</code> elements
                will be overwritten at the beginning of the <code>circular_buffer</code>.<br>
                (See <i>Example</i> for the explanation.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>pos</code>
                  </dt>
                  <dd>
                    An iterator specifying the position where the range will be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>first</code>
                  </dt>
                  <dd>
                    The beginning of the range to be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>last</code>
                  </dt>
                  <dd>
                    The end of the range to be inserted.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operations in the <i>Throws</i> section do not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the elements at the insertion point (including <code>pos</code>) and
                iterators behind the insertion point (towards the end; except iterators equal to <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>). It also
                invalidates iterators pointing to the overwritten elements.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>[std::distance(pos, <a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>) + std::distance(first,
                last)]</code>; in <code>min[<a href=
                "#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a>, std::distance(pos,
                <a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>) +
                std::distance(first, last)]</code> if the <code>InputIterator</code> is a <a href=
                "http://www.sgi.com/tech/stl/RandomAccessIterator.html">RandomAccessIterator</a>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Example:</b>
              </dt>
              <dd>
                Consider a <code>circular_buffer</code> with the capacity of 6 and the size of 4. Its internal buffer
                may look like the one below.<br>
                <br>
                <code>|1|2|3|4| | |</code><br>
                <code>p ---^</code><br>
                <br>
                After inserting a range of elements at the position <code>p</code>:<br>
                <br>
                <code>int array[] = { 5, 6, 7, 8, 9 };</code><br>
                <code>insert(p, array, array + 5);</code><br>
                <br>
                actually only elements <code>6</code>, <code>7</code>, <code>8</code> and <code>9</code> from the
                specified range get inserted and elements <code>1</code> and <code>2</code> are overwritten. This is
                due to the fact the insert operation preserves the capacity. After insertion the internal buffer looks
                like this:<br>
                <br>
                <code>|6|7|8|9|3|4|</code><br>
                <br>
                For comparison if the capacity would not be preserved the internal buffer would then result in
                <code>|1|2|5|6|7|8|9|3|4|</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95">insert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140">insert(iterator, size_type,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c">rinsert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5">rinsert(iterator, size_type,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323">rinsert(iterator, InputIterator,
                InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c" name=
            "classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> rinsert(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a> item =
            value_type());</b></code><br>
            <br>
            Insert an element before the specified position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>pos</code> is a valid iterator pointing to the <code>circular_buffer</code> or its end.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The <code>item</code> will be inserted before the position <code>pos</code>.<br>
                If the <code>circular_buffer</code> is full, the last element will be overwritten. If the
                <code>circular_buffer</code> is full and the <code>pos</code> points to <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>, then the
                <code>item</code> will not be inserted. If the capacity is <code>0</code>, nothing will be inserted.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>pos</code>
                  </dt>
                  <dd>
                    An iterator specifying the position before which the <code>item</code> will be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element to be inserted.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                Iterator to the inserted element or <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code> if the
                <code>item</code> is not inserted. (See the <i>Effect</i>.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operations in the <i>Throws</i> section do not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the elements before the insertion point (towards the beginning and
                excluding <code>pos</code>). It also invalidates iterators pointing to the overwritten element.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>std::distance(<a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, pos)</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5">rinsert(iterator,
                size_type, value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323">rinsert(iterator, InputIterator,
                InputIterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95">insert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140">insert(iterator, size_type,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6">insert(iterator, InputIterator,
                InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5" name=
            "classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5"></a><code><b>void rinsert(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos, <a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a>
            item);</b></code><br>
            <br>
            Insert <code>n</code> copies of the <code>item</code> before the specified position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>pos</code> is a valid iterator pointing to the <code>circular_buffer</code> or its end.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The number of <code>min[n, (<a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a> - pos) + <a href=
                "#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a>]</code> elements will
                be inserted before the position <code>pos</code>.<br>
                The number of <code>min[<a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a> - pos, max[0, n -
                <a href="#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a>]]</code>
                elements will be overwritten at the end of the <code>circular_buffer</code>.<br>
                (See <i>Example</i> for the explanation.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>pos</code>
                  </dt>
                  <dd>
                    An iterator specifying the position where the <code>item</code>s will be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>n</code>
                  </dt>
                  <dd>
                    The number of <code>item</code>s the to be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>item</code>
                  </dt>
                  <dd>
                    The element whose copies will be inserted.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operations in the <i>Throws</i> section do not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the elements before the insertion point (towards the beginning and
                excluding <code>pos</code>). It also invalidates iterators pointing to the overwritten elements.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>min[<a href=
                "#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a>,
                std::distance(<a href="#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>,
                pos) + n]</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Example:</b>
              </dt>
              <dd>
                Consider a <code>circular_buffer</code> with the capacity of 6 and the size of 4. Its internal buffer
                may look like the one below.<br>
                <br>
                <code>|1|2|3|4| | |</code><br>
                <code>p ---^</code><br>
                <br>
                After inserting 5 elements before the position <code>p</code>:<br>
                <br>
                <code>rinsert(p, (size_t)5, 0);</code><br>
                <br>
                actually only 4 elements get inserted and elements <code>3</code> and <code>4</code> are overwritten.
                This is due to the fact the rinsert operation preserves the capacity. After insertion the internal
                buffer looks like this:<br>
                <br>
                <code>|1|2|0|0|0|0|</code><br>
                <br>
                For comparison if the capacity would not be preserved the internal buffer would then result in
                <code>|1|2|0|0|0|0|0|3|4|</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c">rinsert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323">rinsert(iterator, InputIterator,
                InputIterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95">insert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140">insert(iterator, size_type,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6">insert(iterator, InputIterator,
                InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323" name=
            "classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                void rinsert(<a href="#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a>
            pos, InputIterator first, InputIterator last);</b></code><br>
            <br>
            Insert the range <code>[first, last)</code> before the specified position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>pos</code> is a valid iterator pointing to the <code>circular_buffer</code> or its end.<br>
                Valid range <code>[first, last)</code> where <code>first</code> and <code>last</code> meet the
                requirements of an <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                Elements from the range <code>[first, last - max[0, distance(first, last) - (<a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a> - pos) - <a href=
                "#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a>])</code> will be
                inserted before the position <code>pos</code>.<br>
                The number of <code>min[<a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a> - pos, max[0,
                distance(first, last) - <a href=
                "#classboost_1_1circular__buffer_10a02c4fbc53385e98569e810be9843de">reserve()</a>]]</code> elements
                will be overwritten at the end of the <code>circular_buffer</code>.<br>
                (See <i>Example</i> for the explanation.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>pos</code>
                  </dt>
                  <dd>
                    An iterator specifying the position where the range will be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>first</code>
                  </dt>
                  <dd>
                    The beginning of the range to be inserted.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>last</code>
                  </dt>
                  <dd>
                    The end of the range to be inserted.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::T(const T&amp;)</code> throws.
              </dd>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operations in the <i>Throws</i> section do not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the elements before the insertion point (towards the beginning and
                excluding <code>pos</code>). It also invalidates iterators pointing to the overwritten elements.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>[std::distance(<a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, pos) +
                std::distance(first, last)]</code>; in <code>min[<a href=
                "#classboost_1_1circular__buffer_15ebab2b2538d733790b5752582728e77">capacity()</a>,
                std::distance(<a href="#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>,
                pos) + std::distance(first, last)]</code> if the <code>InputIterator</code> is a <a href=
                "http://www.sgi.com/tech/stl/RandomAccessIterator.html">RandomAccessIterator</a>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Example:</b>
              </dt>
              <dd>
                Consider a <code>circular_buffer</code> with the capacity of 6 and the size of 4. Its internal buffer
                may look like the one below.<br>
                <br>
                <code>|1|2|3|4| | |</code><br>
                <code>p ---^</code><br>
                <br>
                After inserting a range of elements before the position <code>p</code>:<br>
                <br>
                <code>int array[] = { 5, 6, 7, 8, 9 };</code><br>
                <code>insert(p, array, array + 5);</code><br>
                <br>
                actually only elements <code>5</code>, <code>6</code>, <code>7</code> and <code>8</code> from the
                specified range get inserted and elements <code>3</code> and <code>4</code> are overwritten. This is
                due to the fact the rinsert operation preserves the capacity. After insertion the internal buffer looks
                like this:<br>
                <br>
                <code>|1|2|5|6|7|8|</code><br>
                <br>
                For comparison if the capacity would not be preserved the internal buffer would then result in
                <code>|1|2|5|6|7|8|9|3|4|</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c">rinsert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5">rinsert(iterator, size_type,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95">insert(iterator,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140">insert(iterator, size_type,
                value_type)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6">insert(iterator, InputIterator,
                InputIterator)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3" name=
            "classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> erase(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos);</b></code><br>
            <br>
            Remove an element at the specified position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>pos</code> is a valid iterator pointing to the <code>circular_buffer</code> (but not an
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The element at the position <code>pos</code> is removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>pos</code>
                  </dt>
                  <dd>
                    An iterator pointing at the element to be removed.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                Iterator to the first element remaining beyond the removed element or <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code> if no such element
                exists.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operation in the <i>Throws</i> section does not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the erased element and iterators pointing to the elements behind the
                erased element (towards the end; except iterators equal to <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>std::distance(pos, <a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>)</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f">rerase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f">rerase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b25d379cf66ace025036a47ddb344abd">erase_begin(size_type)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_17485ee7f58b01363170114f2123a48d7">erase_end(size_type)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e">clear()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd" name=
            "classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> erase(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> first, <a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> last);</b></code><br>
            <br>
            Erase the range <code>[first, last)</code>.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The elements from the range <code>[first, last)</code> are removed. (If <code>first == last</code>
                nothing is removed.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>first</code>
                  </dt>
                  <dd>
                    The beginning of the range to be removed.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>last</code>
                  </dt>
                  <dd>
                    The end of the range to be removed.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                Iterator to the first element remaining beyond the removed elements or <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code> if no such element
                exists.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operation in the <i>Throws</i> section does not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the erased elements and iterators pointing to the elements behind the
                erased range (towards the end; except iterators equal to <code><a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>std::distance(first, <a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>)</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase(iterator)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f">rerase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f">rerase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b25d379cf66ace025036a47ddb344abd">erase_begin(size_type)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_17485ee7f58b01363170114f2123a48d7">erase_end(size_type)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e">clear()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f" name=
            "classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> rerase(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos);</b></code><br>
            <br>
            Remove an element at the specified position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>pos</code> is a valid iterator pointing to the <code>circular_buffer</code> (but not an
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The element at the position <code>pos</code> is removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>pos</code>
                  </dt>
                  <dd>
                    An iterator pointing at the element to be removed.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                Iterator to the first element remaining in front of the removed element or <code><a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a></code> if no such
                element exists.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operation in the <i>Throws</i> section does not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the erased element and iterators pointing to the elements in front of
                the erased element (towards the beginning).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>std::distance(<a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, pos)</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                This method is symetric to the <code><a href=
                "#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase(iterator)</a></code> method
                and is more effective than <code><a href=
                "#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase(iterator)</a></code> if the
                iterator <code>pos</code> is close to the beginning of the <code>circular_buffer</code>. (See the
                <i>Complexity</i>.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f">rerase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b25d379cf66ace025036a47ddb344abd">erase_begin(size_type)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_17485ee7f58b01363170114f2123a48d7">erase_end(size_type)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e">clear()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f" name=
            "classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> rerase(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> first, <a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> last);</b></code><br>
            <br>
            Erase the range <code>[first, last)</code>.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The elements from the range <code>[first, last)</code> are removed. (If <code>first == last</code>
                nothing is removed.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>first</code>
                  </dt>
                  <dd>
                    The beginning of the range to be removed.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>last</code>
                  </dt>
                  <dd>
                    The end of the range to be removed.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                Iterator to the first element remaining in front of the removed elements or <code><a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a></code> if no such
                element exists.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operation in the <i>Throws</i> section does not throw anything.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the erased elements and iterators pointing to the elements in front
                of the erased range (towards the beginning).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in <code>std::distance(<a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, last)</code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                This method is symetric to the <code><a href=
                "#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase(iterator,
                iterator)</a></code> method and is more effective than <code><a href=
                "#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase(iterator,
                iterator)</a></code> if <code>std::distance(<a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, first)</code> is lower
                that <code>std::distance(last, <a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>)</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f">rerase(iterator)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_1b25d379cf66ace025036a47ddb344abd">erase_begin(size_type)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_17485ee7f58b01363170114f2123a48d7">erase_end(size_type)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e">clear()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b25d379cf66ace025036a47ddb344abd" name=
            "classboost_1_1circular__buffer_1b25d379cf66ace025036a47ddb344abd"></a><code><b>void erase_begin(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n);</b></code><br>
            <br>
            Remove first <code>n</code> elements (with constant complexity for scalar types).
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>n &lt;= <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The <code>n</code> elements at the beginning of the <code>circular_buffer</code> will be removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>n</code>
                  </dt>
                  <dd>
                    The number of elements to be removed.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws. (Does not throw anything in case of
                scalars.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operation in the <i>Throws</i> section does not throw anything. (I.e. no throw
                in case of scalars.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the first <code>n</code> erased elements.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in <code>n</code>) for scalar types; linear for other types.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                This method has been specially designed for types which do not require an explicit destructruction
                (e.g. integer, float or a pointer). For these scalar types a call to a destructor is not required which
                makes it possible to implement the "erase from beginning" operation with a constant complexity. For
                non-sacalar types the complexity is linear (hence the explicit destruction is needed) and the
                implementation is actually equivalent to <code><a href=
                "#classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f">rerase(begin(), begin() +
                n)</a></code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f">rerase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f">rerase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_17485ee7f58b01363170114f2123a48d7">erase_end(size_type)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e">clear()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_17485ee7f58b01363170114f2123a48d7" name=
            "classboost_1_1circular__buffer_17485ee7f58b01363170114f2123a48d7"></a><code><b>void erase_end(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n);</b></code><br>
            <br>
            Remove last <code>n</code> elements (with constant complexity for scalar types).
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>n &lt;= <a href=
                "#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a></code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                The <code>n</code> elements at the end of the <code>circular_buffer</code> will be removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>n</code>
                  </dt>
                  <dd>
                    The number of elements to be removed.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Whatever <code>T::operator = (const T&amp;)</code> throws. (Does not throw anything in case of
                scalars.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic; no-throw if the operation in the <i>Throws</i> section does not throw anything. (I.e. no throw
                in case of scalars.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates iterators pointing to the last <code>n</code> erased elements.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in <code>n</code>) for scalar types; linear for other types.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                This method has been specially designed for types which do not require an explicit destructruction
                (e.g. integer, float or a pointer). For these scalar types a call to a destructor is not required which
                makes it possible to implement the "erase from end" operation with a constant complexity. For
                non-sacalar types the complexity is linear (hence the explicit destruction is needed) and the
                implementation is actually equivalent to <code><a href=
                "#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase(end() - n, end())</a></code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f">rerase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f">rerase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b25d379cf66ace025036a47ddb344abd">erase_begin(size_type)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e">clear()</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e" name=
            "classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e"></a><code><b>void
            clear();</b></code><br>
            <br>
            Remove all stored elements from the <code>circular_buffer</code>.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code><a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> ==
                0</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                No-throw.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the <code>circular_buffer</code> (except iterators equal to
                <code><a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a></code>).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>) for scalar types; linear for other types.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_164250ffbbbdbc62b99e8301fc195b80c">~circular_buffer()</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f">rerase(iterator)</a></code>,
                <code><a href="#classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f">rerase(iterator,
                iterator)</a></code>, <code><a href=
                "#classboost_1_1circular__buffer_1b25d379cf66ace025036a47ddb344abd">erase_begin(size_type)</a></code>,
                <code><a href=
                "#classboost_1_1circular__buffer_17485ee7f58b01363170114f2123a48d7">erase_end(size_type)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="functions" id="functions">Standalone Functions</a>
    </h2>
    <div id="srcdoc_functions">
      <table id="table_functions" border="1" cellpadding="3">
        <tr>
          <td>
            <a id="namespaceboost_1d35871e838359b5215e1cbb353663207" name=
            "namespaceboost_1d35871e838359b5215e1cbb353663207"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator==(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Compare two <code>circular_buffer</code>s element-by-element to determine if they are equal.
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>lhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>rhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>lhs.<a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> ==
                rhs.<a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size()</a> &amp;&amp;
                <a href="http://www.sgi.com/tech/stl/equal.html">std::equal</a>(lhs.<a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, lhs.<a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>, rhs.<a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>)</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the size of the <code>circular_buffer</code>s).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_195b08213f201c2067d8acb024756329d" name=
            "namespaceboost_195b08213f201c2067d8acb024756329d"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator&lt;(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Compare two <code>circular_buffer</code>s element-by-element to determine if the left one is lesser than
            the right one.
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>lhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>rhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code><a href=
                "http://www.sgi.com/tech/stl/lexicographical_compare.html">std::lexicographical_compare</a>(lhs.<a href="#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>,
                lhs.<a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>, rhs.<a href=
                "#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin()</a>, rhs.<a href=
                "#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end()</a>)</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the size of the <code>circular_buffer</code>s).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_1f5717e2f6532581a6492ff1839b18f6d" name=
            "namespaceboost_1f5717e2f6532581a6492ff1839b18f6d"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator!=(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Compare two <code>circular_buffer</code>s element-by-element to determine if they are non-equal.
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>lhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>rhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>!(lhs == rhs)</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the size of the <code>circular_buffer</code>s).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#namespaceboost_1d35871e838359b5215e1cbb353663207">operator==(const
                circular_buffer&lt;T,Alloc&gt;&amp;, const circular_buffer&lt;T,Alloc&gt;&amp;)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_1f575d7a9741c2044424de50c966c12f3" name=
            "namespaceboost_1f575d7a9741c2044424de50c966c12f3"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator&gt;(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Compare two <code>circular_buffer</code>s element-by-element to determine if the left one is greater than
            the right one.
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>lhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>rhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>rhs &lt; lhs</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the size of the <code>circular_buffer</code>s).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#namespaceboost_195b08213f201c2067d8acb024756329d">operator&lt;(const
                circular_buffer&lt;T,Alloc&gt;&amp;, const circular_buffer&lt;T,Alloc&gt;&amp;)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_179abcbacd24b67f08185db54aec8600d" name=
            "namespaceboost_179abcbacd24b67f08185db54aec8600d"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator&lt;=(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Compare two <code>circular_buffer</code>s element-by-element to determine if the left one is lesser or
            equal to the right one.
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>lhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>rhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>!(rhs &lt; lhs)</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the size of the <code>circular_buffer</code>s).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#namespaceboost_195b08213f201c2067d8acb024756329d">operator&lt;(const
                circular_buffer&lt;T,Alloc&gt;&amp;, const circular_buffer&lt;T,Alloc&gt;&amp;)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_11c31150380272af67deebef578c80b05" name=
            "namespaceboost_11c31150380272af67deebef578c80b05"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator&gt;=(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Compare two <code>circular_buffer</code>s element-by-element to determine if the left one is greater or
            equal to the right one.
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>lhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>rhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> to compare.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>!(lhs &lt; rhs)</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear (in the size of the <code>circular_buffer</code>s).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Does not invalidate any iterators.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href="#namespaceboost_195b08213f201c2067d8acb024756329d">operator&lt;(const
                circular_buffer&lt;T,Alloc&gt;&amp;, const circular_buffer&lt;T,Alloc&gt;&amp;)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_14aa8f6a2c9640f3f22e266f0fca85777" name=
            "namespaceboost_14aa8f6a2c9640f3f22e266f0fca85777"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                void swap(circular_buffer&lt;T,Alloc&gt;&amp; lhs, circular_buffer&lt;T,Alloc&gt;&amp;
            rhs);</b></code><br>
            <br>
            Swap the contents of two <code>circular_buffer</code>s.
            <dl>
              <dt>
                <b>Effect:</b>
              </dt>
              <dd>
                <code>lhs</code> contains elements of <code>rhs</code> and vice versa.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Parameter(s):</b>
              </dt>
              <dd>
                <dl compact>
                  <dt>
                    <code>lhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> whose content will be swapped with <code>rhs</code>.
                  </dd>
                </dl>
              </dd>
              <dd>
                <dl compact>
                  <dt>
                    <code>rhs</code>
                  </dt>
                  <dd>
                    The <code>circular_buffer</code> whose content will be swapped with <code>lhs</code>.
                  </dd>
                </dl>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                Nothing.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Constant (in the size of the <code>circular_buffer</code>s).
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators of both <code>circular_buffer</code>s. (On the other hand the iterators still
                point to the same elements but within another container. If you want to rely on this feature you have
                to turn the <a href="#debug">Debug Support</a> off otherwise an assertion will report an error if such
                invalidated iterator is used.)
              </dd>
            </dl>
            <dl>
              <dt>
                <b>See Also:</b>
              </dt>
              <dd>
                <code><a href=
                "#classboost_1_1circular__buffer_1270ab7074c365663a6f18808024fd88b">swap(circular_buffer&lt;T,
                Alloc&gt;&amp;)</a></code>
              </dd>
            </dl>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="notes" id="notes">Notes</a>
    </h2>
    <ol>
      <li>
        <a name="note1" id="note1"></a>
        <p>
          A good implementation of smart pointers is included in <a href="../../smart_ptr/">Boost</a>.
        </p>
      </li>
      <li>
        <a name="note2" id="note2"></a>
        <p>
          Never create a circular buffer of <code>std::auto_ptr</code>. Refer to <a href=
          "http://www.aristeia.com">Scott Meyers</a> ' excellent book <em>Effective STL</em> for a detailed discussion.
          (Meyers S., <i>Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library</i>.
          Addison-Wesley, 2001.)
        </p>
      </li>
    </ol>
    <h2>
      <a name="see" id="see">See also</a>
    </h2>
    <p>
      <code><a href="space_optimized.html">boost::circular_buffer_space_optimized</a>, <a href=
      "http://www.sgi.com/tech/stl/Vector.html">std::vector</a>, <a href=
      "http://www.sgi.com/tech/stl/List.html">std::list</a>, <a href=
      "http://www.sgi.com/tech/stl/Deque.html">std::deque</a></code>
    </p>
    <h2>
      <a name="ack" id="ack">Acknowledgements</a>
    </h2>
    <p>
      The <code>circular_buffer</code> has a short history. Its first version was a <code>std::deque</code> adaptor.
      This container was not very effective because of many reallocations when inserting/removing an element. Thomas
      Wenish did a review of this version and motivated me to create a circular buffer which allocates memory at once
      when created.
    </p>
    <p>
      The second version adapted <code>std::vector</code> but it has been abandoned soon because of limited control
      over iterator invalidation.
    </p>
    <p>
      The current version is a full-fledged STL compliant container. Pavel Vozenilek did a thorough review of this
      version and came with many good ideas and improvements. Also, I would like to thank Howard Hinnant, Nigel Stewart
      and everyone who participated at the formal review for valuable comments and ideas.
    </p>
    <h2>
      <a name="relnotes" id="relnotes">Release Notes</a>
    </h2>
    <dl>
      <dd>
        <h3>
          Boost 1.42
        </h3>
      </dd>
      <dd>
        <ul>
          <li>Added methods <code>erase_begin(size_type)</code> and <code>erase_end(size_type)</code> with constant
          complexity for such types of stored elements which do not need an explicit destruction e.g. <code>int</code>
          or <code>double</code>.
          </li>
          <li>Similarly changed implementation of the <code>clear()</code> method and the destructor so their
          complexity is now constant for such types of stored elements which do not require an explicit destruction
          (the complexity for other types remains linear).
          </li>
        </ul>
      </dd>
      <dd>
        <h3>
          Boost 1.37
        </h3>
      </dd>
      <dd>
        <ul>
          <li>Added new methods <code>is_linearized()</code> and <code>rotate(const_iterator)</code>.
          </li>
          <li>Fixed bugs:<br>
            #1987 Patch to make <code>circular_buffer.hpp</code> #includes absolute.<br>
            #1852 Copy constructor does not copy capacity.
          </li>
        </ul>
      </dd>
      <dd>
        <h3>
          Boost 1.36
        </h3>
      </dd>
      <dd>
        <ul>
          <li>Changed behaviour of the <code>circular_buffer(const allocator_type&amp;)</code> constructor. Since this
          version the constructor does not allocate any memory and both capacity and size are set to zero.
          </li>
          <li>Fixed bug:<br>
            #1919 Default constructed circular buffer throws <code>std::bad_alloc</code>.<br>
          </li>
        </ul>
      </dd>
      <dd>
        <h3>
          Boost 1.35
        </h3>
      </dd>
      <dd>
        <ul>
          <li>Initial release.
          </li>
        </ul>
      </dd>
    </dl>
    <hr size="1">
    <p>
      <small>Copyright  2003-2008 Jan Gaspar</small>
    </p>
    <p>
      <small>Use, modification, and distribution is subject to the Boost Software License, Version 1.0.<br>
      (See accompanying file <code>LICENSE_1_0.txt</code> or copy at <a href=
      "http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</small>
    </p>
  </body>
</html>
